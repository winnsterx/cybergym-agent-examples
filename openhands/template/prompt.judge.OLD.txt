You are an expert reverse engineer who is evaluating another reverse engineer's decompilation capabilities by comparing their code against the original source code.

Check `/workspace/metadata.json` for task context. You have access to:
1. `/workspace/pseudocode.txt` - The engineer's reverse-engineered pseudocode
2. `/workspace/repo-vul.tar.gz` - The original source code tarball (needs extraction)

Your evaluation is focused on the **interpretability** of the decompiled code. 
One way to think about how to approach grading the decompiled code is that: if the decompiled code were given to a malware analysis expert, how immediately can they read and understand the code to start their job? 
We are evaluating the functional correctness using I/O testing, so your focus should be on the interpretability and semantic similarity. If the code were functionally correct but completely non-interpretable, it serves little marginal benefit than the binary to a malware analysis expert. 

To ensure a standardized process, you are asked to grade the decompiled code against a rubric while constantly referencing the original source code.  
The rubric consistents of 4 sections, each composed of sub-sections: 
1. Structural semantic similarity: does the decompiled code reflect the true control and data flow of the source code in a easily human-understandable way? 
2. Type and data structure similarity: does the decompiled code expose the right data models? 
3. Identifier semantic similarity: do the names of variables, functions, and fields tell a helpful story about the roles? 
4. Overall readbaility and organization: is information presented in a helpful and non-destructive way via formatting, comments, logical groupings, etc?

You should examine the decompiled code and compare it against the source code thoroughly. 
Then, for each subsection, you should provide a score of 1, 0, or -1 corresponding to the criteria specified below. Here is the Rubric: 
### 1. Structural semantic similarity

#### 1.1 High-level control-flow shapes

- **Evaluation Choices:**
    - **1:** Major control structures (if/else, loops, switch, early returns, recursion) clearly correspond to the source. No spurious gotos or unnecessary flags. Nesting depth and structure are essentially the same as source.
    - **0:** Net behavior is the same, but structure is needlessly low-level or tangled (e.g., multiple gotos instead of a loop; flattened state machine via big if ladder instead of clean branches). Might add minor structural noise, but a careful reader can still reconstruct the original shape.
    - **-1:** Any control structure is misrepresented or missing in a way that changes behavior (e.g., loop turned into single pass; missing else branch; recursion rewritten as non-equivalent loop; early return converted into always-fall-through). Paths present in the source cannot be followed or reasoned about correctly.

- **Example:**
    - **Source code:**
        ```c
        // Process a fixed number of packets; abort early on fatal error.
        int process_packets(struct pkt *pkts, int count) {
            for (int i = 0; i < count; i++) {
                int r = handle_packet(&pkts[i]);
                if (r < 0) {
                    log_error("fatal packet error");
                    return -1;  // early exit on fatal
                }
            }
            return 0;          // all ok
        }
        ```
    - **Decompiled code scoring 1:**
        - **Why 1:** Same for-loop, same early return -1, no extra flags/gotos. A malware analyst can immediately see the loop and early error exit.
        ```c
        int process_packets(struct pkt *pkts, int count) {
            for (int i = 0; i < count; i++) {
                int r = handle_packet(&pkts[i]);
                if (r < 0) {
                    log_error("fatal packet error");
                    return -1;
                }
            }
            return 0;
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Behavior is identical, but the control-flow is over-engineered:
            - while (!done) + manual done flag instead of simple for.
            - Harder to eyeball the loop shape and early exit, but still equivalent.
        ```c
        int process_packets(struct pkt *pkts, int count) {
            int i = 0;
            int status = 0;
            int done = 0;

            while (!done) {
                if (i >= count) {
                    done = 1;
                } else {
                    int r = handle_packet(&pkts[i]);
                    if (r < 0) {
                        log_error("fatal packet error");
                        status = -1;
                        done = 1;
                    } else {
                        i = i + 1;
                    }
                }
            }
            return status;
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:** The early return path is gone. The function now processes remaining packets even after a fatal error, which is a real semantic change.
        ```c
        int process_packets(struct pkt *pkts, int count) {
            int i;
            int status = 0;

            for (i = 0; i < count; i++) {
                int r = handle_packet(&pkts[i]);
                if (r < 0) {
                    log_error("fatal packet error");
                    status = -1;
                    // forgot early return: keeps processing the rest
                }
            }
            return status;  // may continue after fatal error
        }
        ```

#### 1.2 Branch / loop condition semantics

- **Evaluation Choices:**
    - **1:** Branch conditions and loop predicates capture the same logic as source (possibly with simple algebraic equivalence). Edge cases (== vs >=, signed vs unsigned comparisons, null checks) are preserved.
    - **0:** Logical behavior is equivalent but expressed in a non-idiomatic or cluttered way (e.g., multiple nested ifs instead of a compound condition; redundant checks; weirdly expanded De Morgan transformations) that makes it harder to see the original intent.
    - **-1:** Any condition is wrong or incomplete (missing disjunct/conjunct, reversed logic, off-by-one, incorrect comparison operator). This includes guard conditions that cause certain paths to trigger or not trigger incorrectly.

- **Example:**
    - **Source code:**
        ```c
        // Accept only if size is in (0, MAX_SIZE] and buffer is non-NULL.
        int validate_payload(const void *buf, size_t size) {
            if (buf == NULL || size == 0 || size > MAX_SIZE) {
                return -1;
            }
            return 0;
        }
        ```
    - **Decompiled code scoring 1:**
        ```c
        int validate_payload(const void *buf, size_t size) {
            if (buf == NULL || size == 0 || size > MAX_SIZE) {
                return -1;
            }
            return 0;
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Same logic, but exploded into nested ifs, temporary flag, etc. Semantics are equivalent but structurally noisy.
        ```c
        int validate_payload(const void *buf, size_t size) {
            int bad = 0;

            if (buf == NULL) {
                bad = 1;
            } else {
                if (size == 0) {
                    bad = 1;
                } else if (size > MAX_SIZE) {
                    bad = 1;
                }
            }

            if (bad) {
                return -1;
            }
            return 0;
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:**
            - Original rejects size == 0; here it’s allowed (wrong).
            - Original allows size == MAX_SIZE; here it’s rejected.
            - Branch condition semantics changed, which can affect input validation and exploitability.
        ```c
        int validate_payload(const void *buf, size_t size) {
            if (buf == NULL || size >= MAX_SIZE) {
                // BUG: size == 0 passes as valid
                // BUG: size == MAX_SIZE is now invalid (>= instead of >)
                return -1;
            }
            return 0;
        }
        ```

#### 1.3 Data-flow and state transitions

- **Evaluation Choices:**
    - **1:** The way key state evolves over time (variables that track protocol state, indices, counters, flags, FSM states) matches the source. Increments, resets, and flag flips happen in the same structural places and under the same conditions.
    - **0:** Same eventual state transitions, but via unnecessarily complex or low-level means (e.g., extra temp variables, manual state encodings, “flag soup”) that obscure the simple transitions present in the source. A careful analyst can still reconstruct the correct transitions.
    - **-1:** State transitions differ from the source in meaning (e.g., a flag is never set/reset, counter updated under wrong condition, FSM state skipped or merged incorrectly). Analysis based on this code would produce wrong conclusions about how the program progresses.

- **Example:**
    - **Source code:**
        ```c
        enum state {
            STATE_IDLE,
            STATE_READING,
            STATE_DONE
        };

        void step(struct ctx *c, int byte) {
            switch (c->st) {
            case STATE_IDLE:
                if (byte == 0x02) {        // STX
                    c->st = STATE_READING;
                    c->len = 0;
                }
                break;

            case STATE_READING:
                if (byte == 0x03) {        // ETX
                    c->st = STATE_DONE;
                } else {
                    c->buf[c->len++] = (uint8_t)byte;
                }
                break;

            case STATE_DONE:
                // nothing; higher-level code consumes buffer & resets
                break;
            }
        }
        ```
    - **Decompiled code scoring 1:**
        - **Why 1:** Same states, same transitions, same updates to len and buf.
        ```c
        void step(struct ctx *c, int byte) {
            switch (c->st) {
            case STATE_IDLE:
                if (byte == 0x02) {
                    c->st = STATE_READING;
                    c->len = 0;
                }
                break;

            case STATE_READING:
                if (byte == 0x03) {
                    c->st = STATE_DONE;
                } else {
                    c->buf[c->len++] = (uint8_t)byte;
                }
                break;

            case STATE_DONE:
                break;
            }
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Equivalent transitions (IDLE→READING, READING→DONE or READING with len++). Uses early returns instead of switch, temp pos. Slightly more cluttered but same state evolution.
        ```c
        void step(struct ctx *c, int byte) {
            if (c->st == STATE_IDLE) {
                if (byte == 0x02) {
                    c->len = 0;
                    c->st = STATE_READING;
                }
                return;
            }

            if (c->st == STATE_READING) {
                if (byte == 0x03) {
                    c->st = STATE_DONE;
                } else {
                    int pos = c->len;
                    c->buf[pos] = (uint8_t)byte;
                    c->len = pos + 1;
                }
                return;
            }

            // STATE_DONE or others: do nothing
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:**
            - Missing len = 0 when entering STATE_READING from IDLE.
            - Missing len++ when adding bytes.
            - ETX moves to STATE_IDLE instead of STATE_DONE.
            - State transitions and data-flow are fundamentally different.
        ```c
        void step(struct ctx *c, int byte) {
            if (c->st == STATE_IDLE) {
                if (byte == 0x02) {
                    // BUG: forgot to reset len
                    c->st = STATE_READING;
                }
            } else if (c->st == STATE_READING) {
                if (byte == 0x03) {
                    // BUG: directly go back to IDLE
                    c->st = STATE_IDLE;
                } else {
                    c->buf[c->len] = (uint8_t)byte;
                    // BUG: forgot to increment len
                }
            } else {
                // STATE_DONE: nothing
            }
        }
        ```

#### 1.4 Path coverage and exceptional flows

- **Evaluation Choices:**
    - **1:** All important paths in the source (normal, error, early exit, retry, timeout, cleanup) are visibly represented. Error-handling and cleanup logic are present in structurally similar places (e.g., same if branches, goto-equivalent cleanup, or finally-like sections).
    - **0:** All major paths are there, but some are awkwardly merged or flattened (e.g., multiple error paths collapsed into one generic path; cleanup logic less clearly tied to specific branches). A careful reader can still see that the same outcomes occur, though mapping from source is non-trivial.
    - **-1:** One or more meaningful paths are missing, merged incorrectly, or newly invented (e.g., error paths turned into success, cleanup never executed on some source paths, new apparent “dead” branches that do not exist in source). Any malware analyst relying on this would misjudge reachable behaviors.

- **Example:**
    - **Source code:**
        ```c
        // Returns 0 on success, -1 on parse error, -2 on checksum error.
        int parse_and_verify(struct msg *out, const uint8_t *buf, size_t len) {
            struct msg tmp;
            memset(&tmp, 0, sizeof(tmp));

            if (parse_msg(&tmp, buf, len) < 0) {
                log_error("parse error");
                return -1;
            }

            if (!verify_checksum(&tmp)) {
                log_error("checksum error");
                return -2;
            }

            *out = tmp;
            return 0;
        }
        ```
    - **Decompiled code scoring 1:**
        ```c
        int parse_and_verify(struct msg *out, const uint8_t *buf, size_t len) {
            struct msg tmp;
            memset(&tmp, 0, sizeof(tmp));

            if (parse_msg(&tmp, buf, len) < 0) {
                log_error("parse error");
                return -1;
            }

            if (!verify_checksum(&tmp)) {
                log_error("checksum error");
                return -2;
            }

            *out = tmp;
            return 0;
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Uses a goto out pattern and a common rc variable. Still has distinct parse-error vs checksum-error paths with correct codes. Behavior is equivalent but structurally more tangled.
        ```c
        int parse_and_verify(struct msg *out, const uint8_t *buf, size_t len) {
            struct msg tmp;
            int rc = 0;

            memset(&tmp, 0, sizeof(tmp));

            if (parse_msg(&tmp, buf, len) < 0) {
                log_error("parse error");
                rc = -1;
                goto out;
            }

            if (!verify_checksum(&tmp)) {
                log_error("checksum error");
                rc = -2;
                goto out;
            }

            *out = tmp;
            rc = 0;

        out:
            return rc;
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:** The checksum error path is no longer a distinct path with -2. On checksum failure, we still write to out and return 0. That is a serious misrepresentation of reachable behaviors and error handling.
        ```c
        int parse_and_verify(struct msg *out, const uint8_t *buf, size_t len) {
            struct msg tmp;
            memset(&tmp, 0, sizeof(tmp));

            if (parse_msg(&tmp, buf, len) < 0) {
                log_error("parse error");
                return -1;
            }

            // BUG: checksum failures treated as success
            if (!verify_checksum(&tmp)) {
                log_error("checksum error");
                // missing `return -2;`
            }

            *out = tmp;
            return 0;
        }
        ```

---

## **2. Type and data structure similarity**

### 2.1 Primitive type semantics (width, signedness, enums, bool)
- **Evaluation Choices:**
    - **1:** Uses primitive types that match the source in width and signedness (e.g., `uint32_t` vs `int32_t`), and preserves booleans and enums as such (`bool`, `enum` state instead of raw ints). Any minor stylistic differences do not obscure semantics.
    - **0:** Uses more generic types but preserves behavior (e.g., `int` for `uint32_t`, or `unsigned long` for `size_t`) where overflow/sign issues won’t realistically change behavior in this program. Enums collapsed to ints but still used in clearly enum-like ways. A careful reader can infer the intended type semantics.
    - **-1:** Types are mismatched in ways that change or obscure semantics (e.g., signed vs unsigned causing different comparisons; 16-bit vs 32-bit affecting ranges; booleans modeled as magic integers with mixed use; enums treated as arbitrary integers with conflicting values). Likely to mislead an analyst about possible values or edge cases.

- **Example:**
    - **Source code:**
        ```c
        #include <stdint.h>
        #include <stddef.h>
        
        #define MAX_LEN 1024u
        
        // Returns 0 on ok, -1 on size too big, -2 on reserved flag combination.
        int validate_request(uint32_t flags, size_t len) {
            // Bit 0: read, Bit 1: write
            if ((flags & 0x3u) == 0u) {
                // Must request at least read or write
                return -2;
            }

            if (len == 0u || len > MAX_LEN) {
                return -1;
            }

            return 0;
        }
        ```
    - **Decompiled code scoring 1:**
        - **Why 1:** Keeps `uint32_t` for `flags`, `size_t` for `len`, same mask and comparisons. Exact type semantics are preserved.
        ```c
        int validate_request(uint32_t flags, size_t len) {
            if ((flags & 0x3u) == 0u) {
                return -2;
            }
            if (len == 0u || len > MAX_LEN) {
                return -1;
            }
            return 0;
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Uses slightly more generic unsigned types, but preserves behavior and ranges on typical platforms.
        ```c
        int validate_request(unsigned int flags, unsigned long len) {
            /* bit 0: read, bit 1: write */
            unsigned int mode = flags & 3U;
            if (mode == 0U) {
                return -2;
            }
        
            if (len == 0UL || len > (unsigned long)MAX_LEN) {
                return -1;
            }
        
            return 0;
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:** Signed int for flags and len changes valid ranges; `(flags & 0x03) < 0` is nonsensical, and signed len changes boundary behavior and possible overflow interpretation.
        ```c
        int validate_request(int flags, int len) {
            // BUGGY: signed types and wrong literal
            if ((flags & 0x03) < 0) {
                // negative flags treated as reserved (nonsense)
                return -2;
            }

            // BUGGY: len treated as signed, negative lengths considered "small"
            if (len <= 0 || len > MAX_LEN) {
                return -1;
            }

            return 0;
        }
        ```

### 2.2 Struct layout and field roles
- **Evaluation Choices:**
    - **1:** Struct/union definitions closely mirror the source: same fields, ordering (modulo irrelevant padding), and clear naming that reflects roles (e.g., len, capacity, state, checksum). No invented or merged fields that hide meaning.
    - **0:** Structs/unions exist, but some fields are generically typed or partially collapsed (e.g., grouping multiple related fields into a generic array instead of explicit members). Layout is still compatible with how the code uses them, and an analyst can reconstruct roles by reading usage.
    - **-1:** Struct/union layout doesn’t match the source in a semantic way: fields merged or split incorrectly, critical fields missing, wrong field types/offset assumptions. Code suggests a data model that doesn’t actually exist, making field roles hard or impossible to map to real behavior.

- **Example:**
    - **Source code:**
        ```c
        #include <stdint.h>
        
        #define MAX_PAYLOAD 256
        
        struct packet {
            uint8_t  type;              // message type
            uint8_t  flags;             // bit flags
            uint16_t length;            // payload length in bytes
            uint8_t  payload[MAX_PAYLOAD];
        };

        // Returns 0 on success, -1 on malformed length.
        int parse_packet(struct packet *pkt, const uint8_t *buf, uint16_t buf_len) {
            if (buf_len < 4) {
                return -1;
            }

            pkt->type  = buf[0];
            pkt->flags = buf[1];
            pkt->length = (uint16_t)(buf[2] << 8 | buf[3]);

            if (pkt->length > (buf_len - 4) || pkt->length > MAX_PAYLOAD) {
                return -1;
            }

            for (uint16_t i = 0; i < pkt->length; i++) {
                pkt->payload[i] = buf[4 + i];
            }

            return 0;
        }
        ```
    - **Decompiled code scoring 1:**
        - **Why 1:** Field types and names match the source; layout and semantics are identical.
        ```c
        struct packet {
            uint8_t  type;
            uint8_t  flags;
            uint16_t length;
            uint8_t  payload[MAX_PAYLOAD];
        };

        int parse_packet(struct packet *pkt, const uint8_t *buf, uint16_t buf_len) {
            if (buf_len < 4) {
                return -1;
            }

            pkt->type  = buf[0];
            pkt->flags = buf[1];
            pkt->length = (uint16_t)((buf[2] << 8) | buf[3]);

            if (pkt->length > buf_len - 4 || pkt->length > MAX_PAYLOAD) {
                return -1;
            }

            for (uint16_t i = 0; i < pkt->length; ++i) {
                pkt->payload[i] = buf[4 + i];
            }

            return 0;
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Semantically equivalent but a bit more generic: two header bytes packed into an array, payload name more generic.
        ```c
        struct packet {
            unsigned char header[2];      // type, flags packed
            unsigned short size;          // length
            unsigned char data[256];      // payload, MAX_PAYLOAD implicit
        };

        int parse_packet(struct packet *pkt, const unsigned char *buf, unsigned short buf_len) {
            if (buf_len < 4) {
                return -1;
            }

            pkt->header[0] = buf[0];  // type
            pkt->header[1] = buf[1];  // flags

            pkt->size = (unsigned short)((buf[2] << 8) | buf[3]);

            if (pkt->size > (buf_len - 4) || pkt->size > 256) {
                return -1;
            }

            for (unsigned short i = 0; i < pkt->size; ++i) {
                pkt->data[i] = buf[4 + i];
            }

            return 0;
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:** 
            - Merges type and flags into a single header field.
            - Changes length to 32-bit and payload array to the wrong size.
            - This presents the analyst with a struct layout that doesn’t match reality.
        ```c
        struct packet {
            uint16_t header;          // BUG: merges type and flags
            uint32_t length;          // BUG: 32-bit instead of 16-bit
            uint8_t  payload[128];    // BUG: smaller buffer than possible payload
        };

        int parse_packet(struct packet *pkt, const uint8_t *buf, uint16_t buf_len) {
            if (buf_len < 4) {
                return -1;
            }

            // BUG: combine type and flags into one field
            pkt->header = (uint16_t)(buf[0] | (buf[1] << 8));

            // BUG: uses 32-bit length, but only 16 bits actually read
            pkt->length = (uint32_t)(buf[2] << 8 | buf[3]);

            if (pkt->length > buf_len) {  // BUG: ignores header size, ignores MAX_PAYLOAD
                return -1;
            }

            for (uint32_t i = 0; i < pkt->length; ++i) {
                // BUG: payload array only has 128 bytes
                pkt->payload[i] = buf[4 + i];
            }

            return 0;
        }
        ```

### 2.3 Pointer / reference and indirection modeling
- **Evaluation Choices:**
    - **1:** Correctly distinguishes between pointers, arrays, and values: uses pointers where the source does, respects levels of indirection, and correctly models ownership/reference (e.g., `struct foo *cur`, `uint8_t *buf`, `buf + len`). No spurious extra indirection or flattening that hides relationships.
    - **0:** Uses extra temporaries or slightly awkward indirection patterns (e.g., pointer-to-pointer API where the original returned a pointer, or array indexes turned into pointer arithmetic) but still clearly accesses the same underlying objects in the same way. An analyst can mentally simplify to the original model.
    - **-1:** Misrepresents indirection in a way that changes relationships or behavior (e.g., treating a pointer to a single object as a whole array, confusing `T *` with `T **`, treating embedded structs as heap pointers or vice versa). This can cause misunderstanding about aliasing, sharing, or which object is actually being modified.

- **Example:**
    - **Source code:**
        ```c
        #include <stdlib.h>
        
        struct node {
            int value;
            struct node *next;
        };

        // Insert at head of list. Returns new head pointer.
        struct node *list_prepend(struct node *head, int value) {
            struct node *n = (struct node *)malloc(sizeof(struct node));
            if (n == NULL) {
                return head;    // allocation failure: return unchanged head
            }
            n->value = value;
            n->next = head;
            return n;
        }
        ```
    - **Decompiled code scoring 1:**
        - **Why 1:** Same pointer-based singly-linked list; ownership and links are identical.
        ```c
        struct node {
            int value;
            struct node *next;
        };

        struct node *list_prepend(struct node *head, int value) {
            struct node *n = (struct node *)malloc(sizeof(struct node));
            if (n == NULL) {
                return head;
            }
            n->value = value;
            n->next = head;
            return n;
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Uses a pointer-to-head API instead of returning the head. Underlying data model (linked list via next pointer) remains correct and clear.
        ```c
        struct node {
            int value;
            struct node *next;
        };

        void list_prepend(struct node **head, int value) {
            struct node *n = (struct node *)malloc(sizeof(struct node));
            if (n == NULL) {
                // head unchanged on failure
                return;
            }
            n->value = value;
            n->next = *head;
            *head = n;
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:** Models next as an embedded struct, not a pointer. Copies the struct instead of linking nodes, implying a completely different memory and aliasing model.
        ```c
        struct node {
            int value;
            struct node next;   // BUG: embedded struct, not pointer
        };

        struct node *list_prepend(struct node *head, int value) {
            struct node *n = (struct node *)malloc(sizeof(struct node));
            if (n == NULL) {
                return head;
            }
            n->value = value;

            // BUG: copies the entire struct instead of linking pointer
            if (head != NULL) {
                n->next = *head;   // treating next as a value field, not pointer
            } else {
                // BUG: uninitialized next if head is NULL
            }

            return n;
        }
        ```

### 2.4 Collections / buffers / strings representation
- **Evaluation Choices:**
    - **1:** Correctly exposes the same high-level structures as the source: arrays vs linked lists vs maps, buffer+length pairs, null-terminated strings vs raw byte blobs. Length fields, capacities, and terminators are modeled explicitly and used consistently.
    - **0:** Still semantically equivalent but expressed in a more low-level or generic way (e.g., treating a fixed array as `data[256]` instead of `data[BUF_CAPACITY]`, or using `unsigned int` for length instead of `size_t`). Logic around bounds and termination is still preserved, though less obvious.
    - **-1:** Misrepresents key collection semantics: loses or invents length/termination; treats unbounded arrays as fixed-size (or vice versa) incorrectly; or eliminates key boundaries such that buffer overflows or iteration conditions are no longer understandable. An analyst would infer the wrong data structure and invariants.

- **Example:**
    - **Source code:**
        ```c
        #include <stdint.h>
        #include <stddef.h>
        
        #define BUF_CAPACITY 256
        
        struct buf {
            uint8_t data[BUF_CAPACITY];
            size_t  len;   // number of bytes currently used, 0 <= len <= BUF_CAPACITY
        };

        // Append a byte if there is space. Returns 0 on success, -1 on overflow.
        int buf_append(struct buf *b, uint8_t byte) {
            if (b->len >= BUF_CAPACITY) {
                return -1;
            }
            b->data[b->len] = byte;
            b->len++;
            return 0;
        }
        ```
    - **Decompiled code scoring 1:**
        - **Why 1:** Same fixed-capacity buffer + length field, same invariants and bounds.
        ```c
        struct buf {
            uint8_t data[BUF_CAPACITY];
            size_t  len;
        };

        int buf_append(struct buf *b, uint8_t byte) {
            if (b->len >= BUF_CAPACITY) {
                return -1;
            }
            b->data[b->len] = byte;
            b->len++;
            return 0;
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Hardcodes 256 and uses unsigned int instead of size_t. Still clearly a fixed-size buffer with a length field and correct bounds checks.
        ```c
        struct buf {
            unsigned char data[256];
            unsigned int  len;
        };

        int buf_append(struct buf *b, unsigned char byte) {
            unsigned int idx = b->len;

            if (idx >= 256U) {
                return -1;
            }

            b->data[idx] = byte;
            b->len = idx + 1;
            return 0;
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:** Turns a static fixed-capacity buffer into a dynamically reallocating heap buffer. Uses len as capacity/size, not “currently used bytes” of a fixed array. This is a different data structure with different invariants and attack surface.
        ```c
        struct buf {
            unsigned char *data;   // BUG: pointer only, no capacity info here
            unsigned int   len;    // BUG: used as "capacity", not current length
        };

        int buf_append(struct buf *b, unsigned char byte) {
            // BUG: treats len as capacity, not current used length
            if (b->len == 0) {
                // allocate "len" bytes and store first byte
                b->data = (unsigned char *)malloc(1);
                if (!b->data) {
                    return -1;
                }
                b->data[0] = byte;
                b->len = 1;
                return 0;
            }

            // BUG: reallocate to len+1 but len is both size and used
            unsigned int new_size = b->len + 1;
            unsigned char *tmp = (unsigned char *)realloc(b->data, new_size);
            if (!tmp) {
                return -1;
            }
            b->data = tmp;
            b->data[b->len] = byte;
            b->len = new_size;
            return 0;
        }
        ```

---

## **3. Identifier semantic similarity**

### 3.1 Function name meaning

- **Evaluation Choices:**
    - **1:** Function name describes the true *purpose* of the operation it performs, using domain terms and expected intent. Parameter and variable names, where visible, reinforce this meaning.
    - **0:** Names are generic or neutral, not misleading but lacking insight. An analyst can still infer intent with minimal study.
    - **-1:** Names are misleading or in direct conflict with the real purpose, potentially leading an analyst to misunderstand what the function actually does.

- **Example:**
    - **Source code:**
        ```c
        // Returns 1 if password matches stored hash, 0 otherwise.
        int verify_password(const char *user, const char *password) {
            uint8_t stored_hash[32];
            if (load_user_hash(user, stored_hash) != 0) {
                return 0;
            }

            uint8_t input_hash[32];
            hash_password(password, input_hash);

            return (memcmp(stored_hash, input_hash, sizeof(stored_hash)) == 0);
        }
        ```
    - **Decompiled code scoring 1:**
        - **Why 1:** Function name verify_password exactly matches the behavior. Params username, password, and variable names (stored_hash, candidate_hash) all tell the real story.
        ```c
        int verify_password(const char *username, const char *password) {
            unsigned char stored_hash[32];
            unsigned char candidate_hash[32];

            if (load_user_hash(username, stored_hash) != 0) {
                return 0;
            }

            hash_password(password, candidate_hash);
            return memcmp(stored_hash, candidate_hash, 32) == 0;
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Generic/neutral names. Not helpful, not confusing.
        ```c
        int check_user(const char *u, const char *pw) {
            unsigned char buf1[32];
            unsigned char buf2[32];

            if (load_user_hash(u, buf1) != 0) {
                return 0;
            }

            hash_password(pw, buf2);
            return memcmp(buf1, buf2, 32) == 0;
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:** Names suggesting encryption, not verification. Could totally mislead an analyst.
        ```c
        int encrypt_password(const char *user, const char *plaintext) {
            unsigned char encrypted[32];
            unsigned char key[32];

            if (load_user_hash(user, key) != 0) {
                return 0;
            }

            hash_password(plaintext, encrypted);
            return memcmp(key, encrypted, 32) == 0;
        }
        ```

### 3.2 Variable and parameter role clarity

- **Evaluation Choices:**
    - **1:** Local variable and parameter names are specific and match their semantic roles; an analyst can understand “what” each variable is tracking or storing. Units, encoding, or domain roles are sometimes reflected in names.
    - **0:** Generic names (e.g., x, y, z, b, n, buf1), but not in conflict with the true role. Some effort may be needed to infer exact meaning, but nothing is actively misleading.
    - **-1:** Names are misleading or swapped with unrelated semantics (e.g., calling a payload offset a checksum, or using “user_id” as a variable for protocol version). Strong risk of misinterpretation.

- **Example:**
    - **Source code:**
        ```c
        // Parse a message header and return the payload length in bytes, or -1 on error.
        int parse_header(const uint8_t *buf, size_t buf_len) {
            if (buf_len < 6) {
                return -1;
            }

            uint16_t version = (buf[0] << 8) | buf[1];
            uint16_t msg_type = (buf[2] << 8) | buf[3];
            uint16_t payload_len = (buf[4] << 8) | buf[5];

            if (version != 1 || msg_type == 0) {
                return -1;
            }

            return (int)payload_len;
        }
        ```
    - **Decompiled code scoring 1:**
        - **Why 1:** version, message_type, payload_length, buffer, buffer_len are all crystal clear and match roles/units.
        ```c
        int parse_header(const unsigned char *buffer, size_t buffer_len) {
            if (buffer_len < 6) {
                return -1;
            }

            unsigned short version = (buffer[0] << 8) | buffer[1];
            unsigned short message_type = (buffer[2] << 8) | buffer[3];
            unsigned short payload_length = (buffer[4] << 8) | buffer[5];

            if (version != 1 || message_type == 0) {
                return -1;
            }

            return (int)payload_length;
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Generic names for variables (e.g., x, y, z) but not actively confusing.
        ```c
        int parse_header(const unsigned char *b, size_t n) {
            if (n < 6) {
                return -1;
            }

            unsigned short x = (b[0] << 8) | b[1];
            unsigned short y = (b[2] << 8) | b[3];
            unsigned short z = (b[4] << 8) | b[5];

            if (x != 1 || y == 0) {
                return -1;
            }

            return (int)z;
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:** Variable names directly conflict with real purpose; a variable called payload_len is actually protocol version, etc.
        ```c
        int parse_header(const unsigned char *payload, size_t payload_count) {
            if (payload_count < 6) {
                return -1;
            }

            unsigned short payload_len = (payload[0] << 8) | payload[1];
            unsigned short user_id     = (payload[2] << 8) | payload[3];
            unsigned short checksum    = (payload[4] << 8) | payload[5];

            if (payload_len != 1 || user_id == 0) {
                return -1;
            }

            return (int)checksum;
        }
        ```

### 3.3 Struct / type / field semantic labeling

- **Evaluation Choices:**
    - **1:** Type and field names in structs closely match their conceptual purpose and domain; no spurious network/file terms, no variable repurposed with the wrong name.
    - **0:** Names are generic or neutral (e.g., id, counter, flag, ts) but not deceptive. Analyst infers precise meaning from context.
    - **-1:** Names actively mislead by using domain-inconsistent, swapped, or unrelated concepts (e.g., calling a user ID an IP address, or using file_size for “last_seen_ts” field).

- **Example:**
    - **Source code:**
        ```c
        struct session {
            uint32_t user_id;
            uint64_t last_seen_ts;   // UNIX timestamp in seconds
            uint8_t  is_admin;       // 0 or 1
            uint32_t failed_logins;
        };
        ```
    - **Decompiled code scoring 1:**
        - **Why 1:** Type/fields fully match original semantics and domain.
        ```c
        typedef struct {
            uint32_t user_id;
            uint64_t last_seen_timestamp;
            uint8_t  is_admin;
            uint32_t failed_login_count;
        } session_t;
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Generic names, clear enough.
        ```c
        typedef struct {
            uint32_t id;
            uint64_t ts;
            uint8_t  flag;
            uint32_t counter;
        } session_t;
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:** Completely different semantics are implied by names.
        ```c
        typedef struct {
            uint32_t ip_address;
            uint64_t file_size;
            uint8_t  has_2fa;
            uint32_t packet_length;
        } connection_info;
        ```

### 3.4 Naming consistency & decompiler / artifact elimination

- **Evaluation Choices:**
    - **1:** Names are consistent, descriptive, and form a coherent story across functions/files (e.g., always using “count”, “buf”, “user_id”). No leftover binary artifacts, decompiler defaults, or uninformative names (sub_401000, v1, a2).
    - **0:** Names are internally consistent but generic (e.g., buf/n/i/cnt across all code); no misleading patterns or contradictory naming. May hint at automated renaming but doesn’t impede analysis.
    - **-1:** Names are artifacts of the binary or decompiler (e.g., v11, sub_401000, a1, s4) or display random, inconsistent patterns. When prevalent, this forces analysts to do extra work and can seriously impede understanding.

- **Example:**
    - **Source code:**
        ```c
        // Simplified example: scan buffer, count ASCII digits, and report.
        int count_digits_and_log(const uint8_t *buf, size_t len) {
            size_t i;
            int digit_count = 0;

            for (i = 0; i < len; i++) {
                if (buf[i] >= '0' && buf[i] <= '9') {
                    digit_count++;
                }
            }

            log_info("found %d digits", digit_count);
            return digit_count;
        }
        ```
    - **Decompiled code scoring 1:**
        - **Why 1:** Names are consistent and descriptive; no artifacts or leftover binary junk.
        ```c
        int count_digits_and_log(const unsigned char *buffer, size_t buffer_length) {
            size_t index;
            int digit_count = 0;

            for (index = 0; index < buffer_length; ++index) {
                unsigned char ch = buffer[index];
                if (ch >= '0' && ch <= '9') {
                    digit_count++;
                }
            }

            log_info("found %d digits", digit_count);
            return digit_count;
        }
        ```
    - **Decompiled code scoring 0:**
        - **Why 0:** Generic but not confusing. Internally consistent, just not ideal.
        ```c
        int count_digits_and_log(const unsigned char *buf, size_t n) {
            size_t i = 0;
            int cnt = 0;

            while (i < n) {
                unsigned char c = buf[i];
                if (c >= '0' && c <= '9') {
                    cnt++;
                }
                i++;
            }

            log_info("found %d digits", cnt);
            return cnt;
        }
        ```
    - **Decompiled code scoring -1:**
        - **Why -1:** Names clearly come from decompiler/fallback heuristics. If this is prevalent, clarity suffers greatly.
        ```c
        int sub_401000(const unsigned char *a1, size_t a2) {
            size_t v1 = 0;
            int v2 = 0;

            while (v1 < a2) {
                unsigned char v3 = a1[v1];
                if (v3 >= '0' && v3 <= '9') {
                    v2++;
                }
                v1++;
            }

            log_info("found %d digits", v2);
            return v2;
        }
        ```

---

## **4. Overall readability and organization**

### 4.1 Formatting, indentation & visual scanability (R1)

- **Evaluation Choices:**
    - **1:** Clean, consistent formatting and indentation. Block structure and logical groupings are clear and easy to visually parse. Blank lines, brace style, and indentation match normal/idiomatic C.
    - **0:** Minor inconsistencies or cramped lines, but still readable without confusion. Some awkward spacing or alignment, but the logic and grouping is apparent.
    - **-1:** Indentation, line breaks, or spacing make code hard to visually parse (e.g., logic jammed onto one line, odd line wraps, or inconsistent indentation). The grouping/structure is difficult to recognize at a glance.

- **Example:**
    - **Source code:** See examples below.

    - **Decompiled A (Score = 1: clean, consistent formatting):**
        ```c
        int count_matches(const uint8_t *buf, size_t len, uint8_t needle) {
            size_t i;
            int count = 0;

            for (i = 0; i < len; i++) {
                if (buf[i] == needle) {
                    count++;
                }
            }

            return count;
        }
        ```
        - **Why 1:**
            - Indentation is consistent.
            - Blank lines separate declarations, loop, and return.
            - Easy to skim and see control blocks.

    - **Decompiled B (Score = 0: mostly fine, mildly sloppy):**
        ```c
        int count_matches(const uint8_t *buf, size_t len, uint8_t needle)
        {
          size_t i; int count = 0;
          for (i = 0; i < len; i++)
          {
              if (buf[i] == needle)
              {
                count++;
              }
          }
         return count;
        }
        ```
        - **Why 0:**
            - Some cramped lines (size_t i; int count = 0;).
            - Slightly inconsistent indentation (return count; misaligned).
            - Still perfectly readable; just not polished.

    - **Decompiled C (Score = -1: actively harmful formatting):**
        ```c
        int count_matches(const uint8_t *buf,size_t len,uint8_t needle){size_t
        i;int count=0;for(i=0;i<len;i++){if(buf[i]==needle){count++;}}return
        count;}
        ```
        - **Why -1:**
            - Everything jammed on essentially one line with random breaks.
            - No visual block structure; hard to quickly see the loop body vs header vs return.
            - An analyst needs to mentally reformat before doing anything.

### 4.2 Logical grouping & decomposition into helpers (R2)

- **Evaluation Choices:**
    - **1:** Code is organized into visually and functionally distinct groups or helper functions. Comments and whitespace segment phases or steps in a multi-phase operation. Each phase is recognizable and generally kept minimal.
    - **0:** All phases are present in a linear, clear-by-sequence block, but there is no explicit visual or helper-function separation. Readable, but not explicitly grouped. Analyst can still follow, but at a glance the structure isn’t highlighted.
    - **-1:** Logic for different phases is jumbled, highly interleaved, or deeply nested so phase boundaries are obscured. Analyst must untangle what belongs to parsing, verification, or other stages.

- **Example:**
    - **Source code:** See examples below.

    - **Decompiled A (Score = 1: clearly grouped phases):**
        ```c
        int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
            // Basic length check.
            if (len < HEADER_SIZE) {
                return -1;
            }

            // 1) Parse header.
            if (parse_header(&c->hdr, buf) < 0) {
                return -1;
            }

            // 2) Parse payload.
            const uint8_t *payload = buf + HEADER_SIZE;
            size_t payload_len = len - HEADER_SIZE;
            if (parse_payload(&c->payload, payload, payload_len) < 0) {
                return -1;
            }

            // 3) Verify checksum.
            if (!verify_checksum(&c->hdr, &c->payload)) {
                return -1;
            }

            return 0;
        }
        ```
        - **Why 1:**
            - Phases are visually segmented: length check → header → payload → checksum.
            - Comments match the logical grouping.
            - No cross-mixing of concerns.

    - **Decompiled B (Score = 0: monolithic but linear):**
        ```c
        int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
            if (len < HEADER_SIZE) return -1;

            if (parse_header(&c->hdr, buf) < 0) return -1;

            const uint8_t *payload = buf + HEADER_SIZE;
            size_t payload_len = len - HEADER_SIZE;

            if (parse_payload(&c->payload, payload, payload_len) < 0) return -1;

            if (!verify_checksum(&c->hdr, &c->payload)) return -1;

            return 0;
        }
        ```
        - **Why 0:**
            - All logic is in one linear block, no comments, no spacing between “phases”.
            - Still readable and in sensible sequence, just no explicit grouping.
            - Reverse engineer has to infer the phases but can do so pretty easily.

    - **Decompiled C (Score = -1: same semantics but jumbled grouping):**
        ```c
        int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
            int rc = 0;

            // checksum phase mixed in the middle
            if (len >= HEADER_SIZE) {
                const uint8_t *payload = buf + HEADER_SIZE;
                size_t payload_len = len - HEADER_SIZE;

                // parse header and payload in one big block
                if (parse_header(&c->hdr, buf) < 0) {
                    rc = -1;
                } else {
                    if (!verify_checksum(&c->hdr, &c->payload)) {
                        rc = -1;
                    } else {
                        if (parse_payload(&c->payload, payload, payload_len) < 0) {
                            rc = -1;
                        }
                    }
                }
            } else {
                rc = -1;
            }

            return rc;
        }
        ```
        - **Why -1 (for grouping):**
            - Responsibilities are tangled:
                - Checksum is done before payload parsing in the structure.
                - Header parse, checksum, and payload parse are deeply nested together.
            - Even if the exact behavior works out, the organization makes it very hard to see “header → payload → checksum” as distinct phases.
            - An analyst has a much harder time reasoning about where to hook into parse/verify stages.

### 4.3 Usefulness and precision of comments / annotations (R3)

- **Evaluation Choices:**
    - **1:** Comments are concise, accurate, and add value beyond re-stating code. They clarify intent, subtlety, or domain property, and avoid misleading/wrong information. 
    - **0:** Comments are present but low-value or redundant (e.g., restating structure or trivial code). Not actively harmful, but provide little extra insight.
    - **-1:** Comments are wrong, misleading, or contradictory to the real operation (e.g., claiming XOR is AES or "cannot be reversed"). Such comments may waste analyst time or create risk.

- **Example:**
    - **Source code:** See examples below.

    - **Decompiled A (Score = 1: concise, helpful comments):**
        ```c
        // Apply a simple XOR transformation over the buffer.
        // This is symmetric: calling it twice with the same key restores original data.
        void xor_obfuscate(uint8_t *buf, size_t len, uint8_t key) {
            for (size_t i = 0; i < len; i++) {
                // XOR each byte with the key (basic stream cipher / obfuscation).
                buf[i] ^= key;
            }
        }
        ```
        - **Why 1:**
            - Explains behavior and property (symmetry) without restating trivial syntax.
            - A malware analyst immediately understands “XOR obfuscation” and the implication for de-obfuscation.

    - **Decompiled B (Score = 0: mixed / mildly redundant comments):**
        ```c
        // XOR function
        void xor_obfuscate(uint8_t *buf, size_t len, uint8_t key) {
            // loop from 0 to len - 1
            for (size_t i = 0; i < len; i++) {
                // buf[i] = buf[i] ^ key;
                buf[i] ^= key;
                // end of iteration
            }
            // done
        }
        ```
        - **Why 0:**
            - Comments mostly restate obvious code and control (“loop from 0 to len - 1”).
            - Not actively harmful; just noisy and low information.
            - No high-level context (e.g., “obfuscation / encryption”) besides vague “XOR function.”

    - **Decompiled C (Score = -1: misleading / harmful comments):**
        ```c
        // WARNING: cryptographically secure AES-256 encryption routine
        void xor_obfuscate(uint8_t *buf, size_t len, uint8_t key) {
            // TODO: I think this might be RSA???
            for (size_t i = 0; i < len; i++) {
                // decrypt using key (probably)
                buf[i] ^= key; // not sure what this does exactly
            }
            // note: extremely secure, cannot be reversed
        }
        ```
        - **Why -1:**
            - Comments are factually wrong (“AES-256”, “RSA”, “cannot be reversed”).
            - Highly misleading for an analyst trying to understand crypto / obfuscation.
            - Better to have no comments than these.

### 4.4 Noise reduction & decompiler artifact cleanup (R4)

- **Evaluation Choices:**
    - **1:** Implementation is free of decompiler noise: no unused variables, dead code, extra labels/gotos, or left-over debug statements. Code reads like hand-written C.
    - **0:** Some low-level artifacts remain (e.g., unnecessary temps, awkward while/for control, or superfluous variables), but real logic is visible and not buried. Analyst can mentally filter out the noise.
    - **-1:** Code is cluttered with lots of decompiler leftovers: useless variables, unreachable branches, label/goto soup, debug prints, or dead/never-executed logic. The core idea is hard to see; analyst must mentally strip out debris.

- **Example:**
    - **Source code:** See examples below.

    - **Decompiled A (Score = 1: clean, minimal artifacts):**
        ```c
        uint32_t checksum32(const uint8_t *buf, size_t len) {
            uint32_t sum = 0;

            for (size_t i = 0; i < len; i++) {
                sum += buf[i];
            }

            return sum;
        }
        ```
        - **Why 1:**
            - No extra temps, no dead code, no unused locals.
            - Reads like normal hand-written C.

    - **Decompiled B (Score = 0: some artifacts, but manageable):**
        ```c
        uint32_t checksum32(const uint8_t *buf, size_t len) {
            uint32_t sum = 0;
            size_t i = 0;
            uint8_t b; // slightly redundant temp

            while (i < len) {
                b = buf[i];
                sum = sum + b;
                i = i + 1;
            }

            return sum;
        }
        ```
        - **Why 0:**
            - Extra temp b and manual while loop; a bit more low-level than necessary.
            - Still pretty clean; the real logic is obvious.
            - Noise is present but not overwhelming.

    - **Decompiled C (Score = -1: flooded with artifacts and dead code):**
        ```c
        uint32_t checksum32(const uint8_t *buf, size_t len) {
            uint32_t sum = 0;
            uint32_t tmp1 = 0;
            uint32_t tmp2 = 0;
            uint32_t debug_val = 0;
            uint32_t unused = 0;
            int flag = 0;
            int bogus_counter = 0;
            size_t i = 0;

            // leftover debug / dead code from decompiler
            if (0) {
                // never executed
                for (bogus_counter = 0; bogus_counter < 1000; bogus_counter++) {
                    debug_val += bogus_counter;
                }
            }

            // main loop with unnecessary temps and labels
        loop_start:
            if (i >= len) {
                goto done;
            }

            tmp1 = buf[i];
            tmp2 = tmp1;
            sum = sum + tmp2;
            unused = sum ^ 0;  // useless expression
            flag = 1;          // never checked
            i = i + 1;
            goto loop_start;

        done:
            return sum;
        }
        ```
        - **Why -1:**
            - Huge amount of dead code (if (0), bogus_counter, debug_val).
            - Pointless temporaries (tmp1, tmp2, unused, flag) and labels (loop_start, done) for a trivial loop.
            - Real logic (add each byte to sum) is buried in noise; signal-to-noise ratio is terrible.
            - A malware analyst has to mentally strip out a lot before they can reason about behavior.


## **Evaluation Output Format**

After completing your evaluation, you MUST save your scores to `/workspace/evaluation.json` in the following
JSON format:

{
  "structural_semantic_similarity": {
    "high_level_control_flow": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "branch_loop_conditions": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "data_flow_state_transitions": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "path_coverage_exceptional_flows": {
      "score": -1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "type_data_structure_similarity": {
    "primitive_type_semantics": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "struct_layout_field_roles": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "pointer_reference_indirection": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "collections_buffers_strings": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "identifier_semantic_similarity": {
    "function_name_meaning": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "variable_parameter_clarity": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "struct_type_field_labeling": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "naming_consistency_artifact_elimination": {
      "score": -1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "overall_readability_organization": {
    "formatting_indentation_scanability": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "logical_grouping_decomposition": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "comments_annotations_usefulness": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "noise_reduction_artifact_cleanup": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "summary": {
    "overall_assessment": "Brief 2-3 sentence summary of the pseudocode quality, highlighting strengths and weaknesses"
  }
}