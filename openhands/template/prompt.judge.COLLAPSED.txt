You are an expert reverse engineer who is evaluating another reverse engineer's decompilation capabilities by comparing their code against the original source code.

Check `/workspace/metadata.json` for task context. You have access to:
1. `/workspace/pseudocode.txt` - The engineer's reverse-engineered pseudocode
2. `/workspace/repo-vul.tar.gz` - The original source code tarball (needs extraction)

Your evaluation is focused on the **interpretability** of the decompiled code for security analysis.
The key question is: if this decompiled code were given to a malware analyst or security researcher, can they effectively:
- Identify the algorithm or protocol being implemented?
- Trace data flow from inputs to outputs?
- Recognize security-critical operations (crypto, validation, memory operations)?
- Find vulnerabilities or understand the attack surface?

We are evaluating functional correctness separately via I/O testing. Your focus is on whether the decompiled code enables effective analysis. Functionally correct but uninterpretable code provides little more value than the raw binary.

**Grading Philosophy:**
- **Score 1**: Perfect reconstruction OR the best reasonably achievable given binary analysis constraints
- **Score 0**: Requires mental effort but analyst can still work effectively - no active impediments
- **Score -1**: Actively impedes analysis or would lead to wrong conclusions about program behavior

The rubric consists of 4 sections with 10 total sub-criteria, **prioritized by impact on analysis**:
1. **Behavioral Correctness** (2 criteria): Does the code do what the original does?
2. **Data Model Clarity** (3 criteria): Are memory operations and data structures correct?
3. **Naming Quality** (2 criteria): Are decompiler artifacts removed and names consistent?
4. **Readability** (3 criteria): Is the code organized for effective analysis?

You should examine the decompiled code and compare it against the source code thoroughly.
Then, for each sub-criterion, provide a score of 1, 0, or -1. Remember: decompilers face inherent limitations from working with binaries. Don't penalize reasonable accommodations for missing type info or compiler optimizations.

---

# RUBRIC

## **1. Behavioral Correctness**

### 1.1 Control flow and conditions

**Evaluates:** Whether control structures (loops, conditionals, branches) and their predicates (boolean logic, comparisons, boundary checks) enable an analyst to trace execution paths and understand program logic.

**Evaluation Choices:**
    - **1:** Control flow matches source semantics. Conditions preserve exact logic (&&, ||, ==, <, etc.). An analyst can immediately trace execution paths and identify decision points. Compiler-generated patterns (jump tables, loop optimizations) are fine if recognizable.
    - **0:** Semantically equivalent but structurally different due to compiler optimizations or decompiler limitations. Examples: switch→if-else chain, compound predicates→nested ifs, for→while. Logic is correct and traceable with modest effort. An analyst can still identify the algorithm.
    - **-1:** Control flow is wrong or actively misleading. Wrong boolean operators (AND→OR, ==→>=), missing branches, flattened obfuscation left intact, or goto spaghetti that obscures the actual logic. An analyst would draw incorrect conclusions about program behavior.

**Examples:**

**Decompiled code graded 1:**
```c
// Excellent: Logic is clear, analyst immediately sees validation sequence
// (May have minor differences from source: variable names, slightly different conditionals)
int validate_header(uint8_t *packet, size_t packet_len) {
    if (packet_len < 8) {
        return -1;
    }

    uint16_t magic_number = *(uint16_t*)packet;
    if (magic_number != 0xABCD) {
        return -1;
    }

    uint8_t ver = packet[2];
    if (ver < 2 || ver > 5) {
        return -1;
    }

    return 0;
}

// CRC32 algorithm immediately recognizable despite generic names
uint32_t compute_checksum(uint8_t *data, size_t len) {
    uint32_t crc = 0xFFFFFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= data[i];
        for (int j = 0; j < 8; j++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;  // CRC32 polynomial visible
            } else {
                crc >>= 1;
            }
        }
    }
    return ~crc;
}
```

**Decompiled code graded 0:**
```c
// Acceptable: Guard clauses nested instead of early returns, but logic is correct
// Analyst can still trace it with modest effort
int check_header(uint8_t *pkt, size_t len) {
    if (len >= 8) {
        uint16_t magic = *(uint16_t*)pkt;
        if (magic == 0xABCD) {
            uint8_t version = pkt[2];
            if (version >= 2 && version <= 5) {
                return 0;
            }
        }
    }
    return -1;
}

// Acceptable: Compiler optimization pattern (branchless), but CRC32 still recognizable
uint32_t compute_checksum(uint8_t *buf, size_t len) {
    uint32_t crc = 0xFFFFFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= buf[i];
        for (int bit = 0; bit < 8; bit++) {
            uint32_t mask = -(crc & 1);  // branchless conditional
            crc = (crc >> 1) ^ (0xEDB88320 & mask);
        }
    }
    return ~crc;
}
```

**Decompiled code graded -1:**
```c
// WRONG: Boolean logic error - this accepts INVALID versions!
int check_header(uint8_t *pkt, size_t len) {
    if (len < 8) return -1;
    uint16_t magic = *(uint16_t*)pkt;
    if (magic != 0xABCD) return -1;
    uint8_t version = pkt[2];
    if (version < 2 && version > 5) return -1;  // BUG: && should be ||
    return 0;  // accepts version=1, version=10, etc.
}

// WRONG: Loop structure destroyed, algorithm unrecognizable
uint32_t compute_checksum(uint8_t *buf, size_t len) {
    uint32_t crc = 0xFFFFFFFF;
    int state = 0;
loop_start:
    if (state >= len) goto done;
    crc ^= buf[state];
    state++;
    crc = (crc >> 1) ^ 0x12345678;  // BUG: wrong polynomial, missing inner loop
    goto loop_start;
done:
    return ~crc;
}
```

---

### 1.2 Data flow and reachability

**Evaluates:** Whether variable updates (accumulation, state transitions, flag operations) and execution paths (success, error, edge cases) enable an analyst to trace how data evolves and understand what outcomes are possible.

**Evaluation Choices:**
    - **1:** Variable updates match source semantics (accumulation patterns, state transitions, flag operations). All critical paths are present and identifiable. An analyst can trace data dependencies and understand state evolution. Register spilling creating extra temporaries is acceptable.
    - **0:** Semantically equivalent but mechanically different. Extra temporaries from register allocation, paths merged (specific errors→generic error) but behavioral outcomes preserved. An analyst can trace the logic with effort but may need to mentally simplify.
    - **-1:** Wrong operations (= instead of +=, missing ++, flags never set/cleared). Missing critical paths (error handling omitted, validation skipped, cleanup missing). Invented paths that don't exist. An analyst would misunderstand how data flows or what can happen.

**Examples:**

**Decompiled code graded 1:**
```c
// Excellent: State machine transitions clear, all paths present
// (May use slightly different names or enum values than source)
enum conn_state { STATE_IDLE, STATE_CONNECTING, STATE_ACTIVE, STATE_ERROR };

enum conn_state initiate_connection(struct connection *conn, uint8_t *req) {
    if (conn->current_state != STATE_IDLE) {
        return STATE_ERROR;
    }

    if (req[0] != 0x01) {
        return STATE_ERROR;
    }

    conn->current_state = STATE_CONNECTING;
    conn->retry_count = 0;
    conn->flags |= 0x10;  // FLAG_ACTIVE

    if (send_syn(conn) < 0) {
        conn->current_state = STATE_ERROR;
        return STATE_ERROR;
    }

    conn->current_state = STATE_ACTIVE;
    return STATE_ACTIVE;
}
```

**Decompiled code graded 0:**
```c
// Acceptable: Extra temporaries from register allocation, but logic is traceable
int handle_connect(struct connection *conn, uint8_t *req) {
    int curr_state = conn->current_state;
    if (curr_state != 0) {
        return 3;  // error
    }

    uint8_t req_type = req[0];
    if (req_type != 0x01) {
        return 3;
    }

    int new_state = 1;
    conn->current_state = new_state;  // connecting
    int cnt = 0;
    conn->retry_count = cnt;
    int flags_temp = conn->flags | 0x10;
    conn->flags = flags_temp;

    int status = send_syn(conn);
    if (status < 0) {
        conn->current_state = 3;  // error
        return 3;
    }

    conn->current_state = 2;  // connected
    return 2;
}
```

**Decompiled code graded -1:**
```c
// WRONG: Critical state updates missing/incorrect
int handle_connect(struct connection *conn, uint8_t *req) {
    if (conn->current_state != 0) {
        return 3;
    }

    if (req[0] != 0x01) {
        return 3;
    }

    conn->current_state = 1;
    conn->retry_count = 1;  // BUG: should be 0, not 1
    // BUG: Missing flag update (conn->flags |= 0x10)

    if (send_syn(conn) < 0) {
        // BUG: state never set to ERROR before return
        return 3;
    }

    conn->current_state = 2;
    return 2;
}
```

---

## **2. Data Model Clarity**

### 2.1 Type correctness

**Evaluates:** Whether types accurately represent data semantics (pointer vs value, buffer sizes, signedness affecting comparisons) to help an analyst understand memory operations and identify potential vulnerabilities.

**Evaluation Choices:**
    - **1:** Types accurately represent data semantics, especially for security-critical operations. Pointer vs value types correct. Buffer sizes match. Signedness correct where it affects comparisons or overflow. Types support understanding memory layout and potential bugs.
    - **0:** Generic types that work on target platform but lose precision (int for uint32_t, unsigned for size_t). Doesn't obscure analysis - just lacks fine-grained detail. Enums as ints with consistent values. An analyst can infer correct semantics from usage.
    - **-1:** Types actively mislead about operations. Signedness wrong where it matters (size/length as signed, leading to confused comparisons). Wrong pointer levels (T* vs T**). Wrong sizes for buffers/offsets. Would cause analyst to misunderstand memory operations or miss vulnerabilities.

- **Examples:**
    - **Source code:**
        ```c
        // Copy data from network packet
        int copy_payload(uint8_t *dest, size_t dest_size,
                        const uint8_t *packet, uint16_t pkt_len) {
            if (pkt_len > dest_size) {
                return -1;  // would overflow
            }
            memcpy(dest, packet, pkt_len);
            return 0;
        }

        // Parse length-prefixed string
        char* read_string(uint8_t **buf, size_t *remaining) {
            uint8_t len = **buf;
            (*buf)++;
            (*remaining)--;

            if (len > *remaining) return NULL;

            char *str = malloc(len + 1);
            memcpy(str, *buf, len);
            str[len] = '\0';

            *buf += len;
            *remaining -= len;
            return str;
        }
        ```

    - **Decompiled code graded 1:**
        ```c
        // Types clearly show buffer operation and size checks
        int copy_payload(uint8_t *dest, size_t dest_size,
                        const uint8_t *packet, uint16_t pkt_len) {
            if (pkt_len > dest_size) {
                return -1;
            }
            memcpy(dest, packet, pkt_len);
            return 0;
        }

        // Pointer indirection and size tracking clear
        char* read_string(uint8_t **buf, size_t *remaining) {
            uint8_t len = **buf;
            (*buf)++;
            (*remaining)--;

            if (len > *remaining) return NULL;

            char *str = malloc(len + 1);
            memcpy(str, *buf, len);
            str[len] = '\0';

            *buf += len;
            *remaining -= len;
            return str;
        }
        ```

    - **Decompiled code graded 0:**
        ```c
        // Generic unsigned types but semantics clear from context
        int copy_payload(unsigned char *dest, unsigned int dest_size,
                        const unsigned char *packet, unsigned int pkt_len) {
            if (pkt_len > dest_size) {
                return -1;
            }
            memcpy(dest, packet, pkt_len);
            return 0;
        }

        // Flattened pointer - less clear but traceable
        char* read_string(unsigned char *buf, unsigned int remaining) {
            unsigned char len = *buf;
            buf++;
            remaining--;

            if (len > remaining) return NULL;

            char *str = malloc(len + 1);
            memcpy(str, buf, len);
            str[len] = '\0';
            return str;
        }
        ```

    - **Decompiled code graded -1:**
        ```c
        // WRONG: signed types for sizes - can cause negative comparisons!
        int copy_payload(char *dest, int dest_size,
                        const char *packet, int pkt_len) {
            if (pkt_len > dest_size) {  // BUG: negative pkt_len bypasses check
                return -1;
            }
            memcpy(dest, packet, pkt_len);
            return 0;
        }

        // WRONG: wrong pointer level - completely changes semantics
        char* read_string(unsigned char *buf, unsigned int remaining) {
            unsigned char *len_ptr = buf;  // BUG: len is value not pointer
            buf++;
            remaining--;

            if (*len_ptr > remaining) return NULL;  // wrong dereference

            char *str = malloc(*len_ptr + 1);
            memcpy(str, buf, *len_ptr);
            str[*len_ptr] = '\0';
            return str;
        }
        ```

---

### 2.2 Structure layout

**Evaluates:** Whether struct/union definitions have correct fields, types, and memory layout to help an analyst understand data organization and recognize patterns (protocol headers, linked structures).

**Evaluation Choices:**
    - **1:** Struct/union layout matches source semantics. Fields are present with correct types and roles. Padding and alignment appropriate. An analyst can understand data organization, recognize patterns (e.g., protocol headers, linked structures), and reason about memory layout.
    - **0:** Correct memory layout but some abstraction loss. Generic field names (field0, field1) or adjacent fields packed into arrays (header[4] instead of distinct type/flags/len). An analyst can reconstruct structure purpose from usage context.
    - **-1:** Structure layout wrong. Fields merged incorrectly, wrong offsets, critical fields missing, wrong sizes. Nested structures flattened or invented. An analyst would misunderstand data relationships or memory layout.

- **Examples:**
    - **Source code:**
        ```c
        struct packet {
            uint8_t  type;
            uint8_t  flags;
            uint16_t length;
            uint8_t  payload[256];
        };
        ```

    - **Decompiled code graded 1:**
        ```c
        struct packet {
            uint8_t  type;
            uint8_t  flags;
            uint16_t length;
            uint8_t  payload[256];
        };
        ```

    - **Decompiled code graded 0:**
        ```c
        // Generic names, header bytes packed
        struct packet {
            unsigned char header[2];  // type, flags
            unsigned short size;      // length
            unsigned char data[256];  // payload
        };
        ```

    - **Decompiled code graded -1:**
        ```c
        // WRONG: merges type+flags, wrong sizes
        struct packet {
            uint16_t header;       // BUG: merges type and flags
            uint32_t length;       // BUG: 32-bit instead of 16-bit
            uint8_t  payload[128]; // BUG: wrong size
        };
        ```

---

### 2.3 Pointers and collections

**Evaluates:** Whether pointer indirection (T* vs T**, value vs reference) and collection semantics (fixed/dynamic arrays, buffer+size pairs, bounds) enable an analyst to reason about memory safety, aliasing, and buffer boundaries.

**Evaluation Choices:**
    - **1:** Pointer indirection matches source (T* vs T**, value vs pointer). Collection semantics clear (fixed array with bounds, dynamic buffer with size tracking, null-terminated strings). An analyst can reason about memory safety, aliasing, and buffer boundaries. Understands ownership and lifetime.
    - **0:** Semantically equivalent but mechanically different. API variations (out-param as return value, pointer-to-pointer flattened). Generic buffer sizes that are "big enough." Bounds checking logic preserved even if presentation differs. An analyst can trace memory operations with effort.
    - **-1:** Indirection wrong (T* treated as T**, embedded vs heap confused, array vs pointer wrong). Collection boundaries wrong or missing (unbounded buffer, size/count confused, off-by-one in allocation). Would cause analyst to misunderstand memory model or miss buffer overflows.

- **Examples:**
    - **Source code:**
        ```c
        struct node {
            int value;
            struct node *next;  // pointer
        };

        struct node *prepend(struct node *head, int val) {
            struct node *n = malloc(sizeof(struct node));
            if (!n) return head;
            n->value = val;
            n->next = head;
            return n;
        }

        #define BUF_CAPACITY 256
        struct buf {
            uint8_t data[BUF_CAPACITY];  // fixed array
            size_t  len;
        };
        ```

    - **Decompiled code graded 1:**
        ```c
        struct node {
            int value;
            struct node *next;
        };

        struct node *prepend(struct node *head, int val) {
            struct node *n = malloc(sizeof(struct node));
            if (!n) return head;
            n->value = val;
            n->next = head;
            return n;
        }

        struct buf {
            uint8_t data[BUF_CAPACITY];
            size_t  len;
        };
        ```

    - **Decompiled code graded 0:**
        ```c
        // Different API but same linked list model
        void prepend(struct node **head, int val) {
            struct node *n = malloc(sizeof(struct node));
            if (!n) return;
            n->value = val;
            n->next = *head;
            *head = n;
        }

        // Hardcoded size, generic types
        struct buf {
            unsigned char data[256];
            unsigned int  len;
        };
        ```

    - **Decompiled code graded -1:**
        ```c
        // WRONG: embedded struct instead of pointer
        struct node {
            int value;
            struct node next;  // BUG: value not pointer!
        };

        // WRONG: dynamic realloc instead of fixed array
        struct buf {
            unsigned char *data;  // BUG: pointer not array
            unsigned int   len;
        };
        ```

---

## **3. Naming Quality**

### 3.1 Artifact elimination and consistency

**Evaluates:** Whether decompiler artifacts (`v11`, `sub_401000`, `a1`, `FUN_00401000`) are removed and naming conventions are consistent.

**This is the HIGHEST PRIORITY criterion for naming.** Binary/tool artifacts are hard blockers for effective analysis.

**Evaluation Choices:**
    - **1:** Zero decompiler artifacts. All function names, variables, and parameters use human names (not generated symbols). Naming conventions consistent throughout (all snake_case or all camelCase, not mixed randomly). Professional presentation. Common loop vars (i, j, k) and generic but reasonable names (buf, len, count) are perfectly acceptable.
    - **0:** No decompiler artifacts but extremely minimal naming (func1, func2, var1, var2). Or minor inconsistencies in convention (mostly snake_case with occasional camelCase). Generic but internally consistent. Doesn't impede analysis - just lacks polish.
    - **-1:** Decompiler artifacts present (v11, sub_401000, a1-a9, param_1, FUN_XXXXX, unaff_*, local_38). OR wildly inconsistent naming that creates confusion. Forces analyst to mentally translate or track multiple naming schemes. These artifacts are immediate red flags in triage.

- **Examples:**
    - **Source code:**
        ```c
        int validate_token(const char *token, size_t len) {
            if (len < 16) return 0;

            uint8_t hash[32];
            compute_sha256(hash, (uint8_t*)token, len);

            for (int i = 0; i < 32; i++) {
                if (hash[i] != expected_hash[i]) {
                    return 0;
                }
            }
            return 1;
        }
        ```

    - **Decompiled code graded 1:**
        ```c
        // Clean, consistent, no artifacts - generic names are fine
        int validate_token(const char *token, size_t len) {
            if (len < 16) return 0;

            uint8_t hash[32];
            compute_sha256(hash, (uint8_t*)token, len);

            for (int i = 0; i < 32; i++) {
                if (hash[i] != expected_hash[i]) {
                    return 0;
                }
            }
            return 1;
        }

        // Also acceptable - consistent generic names
        int check_auth(const char *buf, size_t n) {
            if (n < 16) return 0;

            uint8_t digest[32];
            compute_sha256(digest, (uint8_t*)buf, n);

            for (int i = 0; i < 32; i++) {
                if (digest[i] != expected[i]) {
                    return 0;
                }
            }
            return 1;
        }
        ```

    - **Decompiled code graded 0:**
        ```c
        // Very minimal but no artifacts - consistent pattern
        int func3(const char *arg1, size_t arg2) {
            if (arg2 < 16) return 0;

            uint8_t arr1[32];
            compute_sha256(arr1, (uint8_t*)arg1, arg2);

            for (int i = 0; i < 32; i++) {
                if (arr1[i] != arr2[i]) {
                    return 0;
                }
            }
            return 1;
        }
        ```

    - **Decompiled code graded -1:**
        ```c
        // BLOCKER: decompiler artifacts present
        int FUN_00401234(const char *a1, size_t a2) {
            if (a2 < 0x10) return 0;

            uint8_t local_38[32];
            compute_sha256(local_38, (uint8_t*)a1, a2);

            int v7 = 0;
            while (v7 < 0x20) {
                if (local_38[v7] != DAT_00404000[v7]) {
                    return 0;
                }
                v7 = v7 + 1;
            }
            return 1;
        }

        // Also BLOCKER: wildly inconsistent
        int CheckAuth_Token(const char *a1, size_t LEN) {
            uint8_t v3[32];  // mixing styles
            compute_sha256(v3, (uint8_t*)a1, LEN);
            for (int param_7 = 0; param_7 < 32; param_7++) {
                if (v3[param_7] != expected[param_7]) return 0;
            }
            return 1;
        }
        ```

---

### 3.2 Semantic naming

**Evaluates:** Whether names convey purpose and intent (function operations, variable roles, data types) or are at least neutral and non-misleading.

**Evaluation Choices:**
    - **1:** Names convey purpose and intent. Functions describe operations (validate_signature, parse_header, decrypt_payload). Variables describe roles (user_id, packet_len, retry_count). Types reflect domain (struct connection, enum state). An analyst immediately understands purpose from names alone.
    - **0:** Neutral generic names that don't mislead (process, handle, check, buf, data, count, state). Don't add insight but don't obscure. An analyst must read implementation to understand purpose but names don't create false assumptions.
    - **-1:** Names are actively misleading. Function named "encrypt" does XOR. Field named "checksum" is actually a version number. Variable "user_id" holds IP address. Creates false mental models that an analyst must unlearn. Worse than generic names.

- **Examples:**
    - **Source code:**
        ```c
        // XOR obfuscation (symmetric)
        void apply_xor_mask(uint8_t *data, size_t len, uint8_t key) {
            for (size_t i = 0; i < len; i++) {
                data[i] ^= key;
            }
        }

        struct auth_token {
            uint32_t user_id;
            uint64_t expire_ts;
            uint8_t  signature[32];
        };
        ```

    - **Decompiled code graded 1:**
        ```c
        // Descriptive names - analyst immediately knows it's XOR
        void apply_xor_mask(uint8_t *data, size_t len, uint8_t key) {
            for (size_t i = 0; i < len; i++) {
                data[i] ^= key;
            }
        }

        struct auth_token {
            uint32_t user_id;
            uint64_t expire_ts;
            uint8_t  signature[32];
        };
        ```

    - **Decompiled code graded 0:**
        ```c
        // Generic but not misleading - analyst reads code to understand
        void transform(uint8_t *buf, size_t len, uint8_t param) {
            for (size_t i = 0; i < len; i++) {
                buf[i] ^= param;
            }
        }

        struct token {
            uint32_t id;
            uint64_t timestamp;
            uint8_t  data[32];
        };
        ```

    - **Decompiled code graded -1:**
        ```c
        // MISLEADING: claims AES encryption but it's just XOR!
        void aes_encrypt(uint8_t *plaintext, size_t len, uint8_t key) {
            for (size_t i = 0; i < len; i++) {
                plaintext[i] ^= key;  // not AES at all!
            }
        }

        // MISLEADING: field purposes wrong
        struct auth_token {
            uint32_t session_id;    // WRONG: actually user_id
            uint64_t created_at;    // WRONG: actually expiration time
            uint8_t  checksum[32];  // WRONG: actually signature
        };
        ```

---

## **4. Readability**

### 4.1 Visual formatting

**Evaluates:** Whether formatting (indentation, spacing, brace style) is clean and consistent enough to visually parse block structure without effort.

**Evaluation Choices:**
    - **1:** Clean, consistent formatting and indentation. Block structure clear. Blank lines, brace style, indentation match idiomatic C. Easy to scan.
    - **0:** Minor inconsistencies or cramped lines but readable. Some awkward spacing but logic apparent.
    - **-1:** Formatting makes code hard to parse (logic jammed on one line, inconsistent indentation). Structure difficult to recognize at a glance.

- **Examples:**
    - **Decompiled code graded 1:**
        ```c
        int count_matches(const uint8_t *buf, size_t len, uint8_t needle) {
            size_t i;
            int count = 0;

            for (i = 0; i < len; i++) {
                if (buf[i] == needle) {
                    count++;
                }
            }

            return count;
        }
        ```

    - **Decompiled code graded 0:**
        ```c
        int count_matches(const uint8_t *buf, size_t len, uint8_t needle)
        {
          size_t i; int count = 0;  // cramped
          for (i = 0; i < len; i++)
          {
              if (buf[i] == needle)
              {
                count++;
              }
          }
         return count;  // misaligned
        }
        ```

    - **Decompiled code graded -1:**
        ```c
        int count_matches(const uint8_t *buf,size_t len,uint8_t needle){size_t
        i;int count=0;for(i=0;i<len;i++){if(buf[i]==needle){count++;}}return
        count;}
        ```

---

### 4.2 Logical organization and documentation

**Evaluates:** Whether functional phases (validation → parsing → processing) are separated and whether comments add insight or cause confusion.

**Evaluation Choices:**
    - **1:** Functional phases clearly separated (blank lines, helper functions, or comments marking sections). An analyst can quickly locate relevant operations (where is validation? where is crypto?). Comments explain non-obvious intent, algorithms, or security properties. Aid rapid triage.
    - **0:** Linear organization without explicit structure but logical flow apparent. No comments or low-value comments that restate code ("increment i") but don't mislead. An analyst can follow the flow but must read linearly.
    - **-1:** Logic is tangled - phases interleaved, validation mixed with processing, error handling scattered. OR comments actively mislead (wrong algorithm names, false security claims). An analyst must untangle structure or correct false assumptions from comments.

- **Examples:**
    - **Decompiled code graded 1:**
        ```c
        int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
            // Basic length check
            if (len < HEADER_SIZE) return -1;

            // Phase 1: Parse header
            if (parse_header(&c->hdr, buf) < 0) return -1;

            // Phase 2: Parse payload
            const uint8_t *payload = buf + HEADER_SIZE;
            if (parse_payload(&c->payload, payload, len - HEADER_SIZE) < 0) return -1;

            // Phase 3: Verify checksum
            if (!verify_checksum(&c->hdr, &c->payload)) return -1;

            return 0;
        }

        // Apply XOR transformation.
        // Symmetric: calling twice with same key restores data.
        void xor_obfuscate(uint8_t *buf, size_t len, uint8_t key) {
            for (size_t i = 0; i < len; i++) {
                buf[i] ^= key;
            }
        }
        ```

    - **Decompiled code graded 0:**
        ```c
        // Linear, no comments, but sequence clear
        int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
            if (len < HEADER_SIZE) return -1;
            if (parse_header(&c->hdr, buf) < 0) return -1;
            const uint8_t *payload = buf + HEADER_SIZE;
            if (parse_payload(&c->payload, payload, len - HEADER_SIZE) < 0) return -1;
            if (!verify_checksum(&c->hdr, &c->payload)) return -1;
            return 0;
        }

        // XOR function
        void xor_obfuscate(uint8_t *buf, size_t len, uint8_t key) {
            // loop from 0 to len-1
            for (size_t i = 0; i < len; i++) {
                buf[i] ^= key;  // XOR operation
            }
        }
        ```

    - **Decompiled code graded -1:**
        ```c
        // Phases jumbled: checksum before payload
        int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
            int rc = 0;
            if (len >= HEADER_SIZE) {
                if (parse_header(&c->hdr, buf) < 0) {
                    rc = -1;
                } else {
                    // Checksum before parsing payload (wrong order)
                    if (!verify_checksum(&c->hdr, &c->payload)) {
                        rc = -1;
                    } else {
                        const uint8_t *payload = buf + HEADER_SIZE;
                        if (parse_payload(&c->payload, payload, len - HEADER_SIZE) < 0) {
                            rc = -1;
                        }
                    }
                }
            } else {
                rc = -1;
            }
            return rc;
        }

        // MISLEADING COMMENTS
        // WARNING: cryptographically secure AES-256 encryption
        void xor_obfuscate(uint8_t *buf, size_t len, uint8_t key) {
            // TODO: might be RSA???
            for (size_t i = 0; i < len; i++) {
                buf[i] ^= key;  // extremely secure, cannot be reversed
            }
        }
        ```

---

### 4.3 Noise reduction

**Evaluates:** Whether the code is free of clutter (unused variables, dead code, goto spaghetti) that would obscure the actual algorithm.

**Evaluation Choices:**
    - **1:** Clean code focused on actual logic. No unused variables, dead code, unreachable branches, or leftover debug statements. Extra temporaries from register allocation are fine if they follow clear patterns. Logic is immediately visible.
    - **0:** Some mechanical artifacts present (extra temporaries, redundant assignments, unnecessary labels) but they follow consistent patterns. Core algorithm visible with modest mental filtering. An analyst can identify the real operations.
    - **-1:** Heavily cluttered. Unused variables, unreachable dead code, goto spaghetti, debug statements, complex patterns that obscure simple operations. An analyst must mentally strip significant debris before understanding the algorithm. Slows down triage significantly.

- **Examples:**
    - **Decompiled code graded 1:**
        ```c
        uint32_t checksum32(const uint8_t *buf, size_t len) {
            uint32_t sum = 0;
            for (size_t i = 0; i < len; i++) {
                sum += buf[i];
            }
            return sum;
        }
        ```

    - **Decompiled code graded 0:**
        ```c
        // Extra temp, manual while, but logic clear
        uint32_t checksum32(const uint8_t *buf, size_t len) {
            uint32_t sum = 0;
            size_t i = 0;
            uint8_t b;

            while (i < len) {
                b = buf[i];
                sum = sum + b;
                i = i + 1;
            }

            return sum;
        }
        ```

    - **Decompiled code graded -1:**
        ```c
        // Flooded with artifacts
        uint32_t checksum32(const uint8_t *buf, size_t len) {
            uint32_t sum = 0;
            uint32_t tmp1 = 0;
            uint32_t tmp2 = 0;
            uint32_t debug_val = 0;
            uint32_t unused = 0;
            int flag = 0;
            size_t i = 0;

            // Dead code
            if (0) {
                for (int j = 0; j < 1000; j++) {
                    debug_val += j;
                }
            }

        loop_start:
            if (i >= len) goto done;
            tmp1 = buf[i];
            tmp2 = tmp1;
            sum = sum + tmp2;
            unused = sum ^ 0;
            flag = 1;
            i = i + 1;
            goto loop_start;

        done:
            return sum;
        }
        ```

---

## **Evaluation Output Format**

After completing your evaluation, you MUST save your scores to `/workspace/evaluation.json` in the following JSON format:

```json
{
  "behavioral_correctness": {
    "control_flow_and_conditions": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "data_flow_and_reachability": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "data_model_clarity": {
    "type_correctness": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "structure_layout": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "pointers_and_collections": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "naming_quality": {
    "semantic_naming": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "consistency_and_artifacts": {
      "score": -1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "readability": {
    "visual_formatting": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "logical_organization_and_documentation": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "noise_reduction": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "summary": {
    "overall_assessment": "Brief 2-3 sentence summary of the pseudocode quality, highlighting strengths and weaknesses"
  }
}
```
