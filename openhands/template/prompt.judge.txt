You are an expert reverse engineer who is evaluating another reverse engineer's decompilation capabilities by comparing their code against the original source code.

Check `/workspace/metadata.json` for task context. You have access to:
1. `/workspace/pseudocode.txt` - The engineer's reverse-engineered pseudocode
2. `/workspace/repo-vul.tar.gz` - The original source code tarball (needs extraction)

Your evaluation is focused on the **interpretability** of the decompiled code for security analysis.
The key question is: if this decompiled code were given to a malware analyst or security researcher, can they effectively:
- Identify the algorithm or protocol being implemented?
- Trace data flow from inputs to outputs?
- Recognize security-critical operations (crypto, validation, memory operations)?
- Find vulnerabilities or understand the attack surface?

We are evaluating functional correctness separately via I/O testing. Your focus is on whether the decompiled code enables effective analysis. Functionally correct but uninterpretable code provides little more value than the raw binary.

**Grading Philosophy (5-Point Scale):**
- **Score 2**: Excellent - Near-perfect reconstruction given binary constraints. Analyst can work immediately.
- **Score 1**: Good - Semantically correct with minor issues. Analyst works efficiently with modest mental adjustments.
- **Score 0**: Acceptable - Correct but requires effort. Analyst can complete task but with noticeable friction.
- **Score -1**: Poor - Significant problems that impede analysis. Analyst spends substantial time deciphering or correcting.
- **Score -2**: Unusable - Critical errors or heavy artifacts. Would mislead analyst or require near-complete rewrite.

The rubric consists of 4 sections with 10 total sub-criteria, **prioritized by impact on analysis**:
1. **Behavioral Correctness** (2 criteria): Does the code do what the original does?
2. **Data Model Clarity** (3 criteria): Are memory operations and data structures correct?
3. **Naming Quality** (2 criteria): Are decompiler artifacts removed and names consistent?
4. **Readability** (3 criteria): Is the code organized for effective analysis?

You should examine the decompiled code and compare it against the source code thoroughly.
Then, for each sub-criterion, provide a score from -2 to 2. Remember: decompilers face inherent limitations from working with binaries. Don't penalize reasonable accommodations for missing type info or compiler optimizations.

---

# RUBRIC

## **1. Behavioral Correctness**

### 1.1 Control flow and conditions

**Evaluates:** Whether control structures (loops, conditionals, branches) and their predicates (boolean logic, comparisons, boundary checks) enable an analyst to trace execution paths and understand program logic.

**Evaluation Choices:**
    - **2 (Excellent):** Control flow matches source semantics. Conditions preserve exact logic. Clean structure (early returns, compound predicates, appropriate loop constructs). Analyst immediately identifies algorithm and decision points. Recognizable compiler patterns (jump tables, loop optimizations) are fine.
    - **1 (Good):** Semantically equivalent but structurally different due to decompiler/compiler. Examples: guard clauses nested instead of early returns, switch→if-else chain, compound predicates→nested ifs. Logic correct and traceable with brief examination.
    - **0 (Acceptable):** Correct logic but awkward presentation. May have branchless optimizations, manual state tracking, or verbose conditionals. Analyst can identify algorithm with focused effort and mental simplification.
    - **-1 (Poor):** Some control flow issues. Minor logic errors (off-by-one in bounds), missing edge case handling, or control structure obscures pattern. Analyst must carefully verify correctness or work around confusion.
    - **-2 (Unusable):** Control flow wrong or completely obscured. Wrong boolean operators (AND→OR), missing critical branches, goto spaghetti hiding algorithm. Would lead analyst to wrong conclusions about behavior.

**Examples:**

**Score 2 (Excellent):**
```c
// Crystal clear validation logic, immediately readable
int validate_packet_header(uint8_t *packet, size_t len) {
    if (len < 8) return -1;

    uint16_t magic = *(uint16_t*)packet;
    if (magic != 0xABCD) return -1;

    uint8_t version = packet[2];
    if (version < 2 || version > 5) return -1;

    return 0;
}

// CRC32 algorithm immediately recognizable, clean loops
uint32_t compute_crc32(uint8_t *data, size_t len) {
    uint32_t crc = 0xFFFFFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= data[i];
        for (int bit = 0; bit < 8; bit++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc >>= 1;
            }
        }
    }
    return ~crc;
}
```

**Score 1 (Good):**
```c
// Guard clauses nested but logic intact, takes 10-20 seconds to parse
int validate_packet_header(uint8_t *pkt, size_t len) {
    if (len >= 8) {
        uint16_t magic = *(uint16_t*)pkt;
        if (magic == 0xABCD) {
            uint8_t ver = pkt[2];
            if (ver >= 2 && ver <= 5) {
                return 0;
            }
        }
    }
    return -1;
}

// Compound conditions split, but CRC still recognizable
uint32_t compute_crc32(uint8_t *data, size_t len) {
    uint32_t crc = 0xFFFFFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= data[i];
        for (int bit = 0; bit < 8; bit++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;
            }
            if (!(crc & 1)) {
                crc >>= 1;
            }
        }
    }
    return ~crc;
}
```

**Score 0 (Acceptable):**
```c
// More verbose, requires mental simplification but logically correct
int validate_packet_header(uint8_t *pkt, size_t len) {
    int result = -1;
    int valid = 0;

    if (len >= 8) {
        valid = 1;
    }

    if (valid) {
        uint16_t magic = *(uint16_t*)pkt;
        if (magic != 0xABCD) {
            valid = 0;
        }
    }

    if (valid) {
        uint8_t ver = pkt[2];
        if (ver < 2 || ver > 5) {
            valid = 0;
        }
    }

    if (valid) {
        result = 0;
    }

    return result;
}

// Branchless optimization - CRC recognizable but requires focused examination
uint32_t compute_crc32(uint8_t *data, size_t len) {
    uint32_t crc = 0xFFFFFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= data[i];
        for (int bit = 0; bit < 8; bit++) {
            uint32_t mask = -(crc & 1);  // branchless
            crc = (crc >> 1) ^ (0xEDB88320 & mask);
        }
    }
    return ~crc;
}
```

**Score -1 (Poor):**
```c
// Off-by-one error in version check - subtle bug
int validate_packet_header(uint8_t *pkt, size_t len) {
    if (len < 8) return -1;
    uint16_t magic = *(uint16_t*)pkt;
    if (magic != 0xABCD) return -1;
    uint8_t ver = pkt[2];
    if (ver < 2 || ver >= 5) return -1;  // BUG: should be > not >=
    return 0;
}

// Inner loop partially unrolled incorrectly
uint32_t compute_crc32(uint8_t *data, size_t len) {
    uint32_t crc = 0xFFFFFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= data[i];
        // Unrolled but only does 4 iterations instead of 8
        for (int bit = 0; bit < 4; bit++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc >>= 1;
            }
        }
    }
    return ~crc;
}
```

**Score -2 (Unusable):**
```c
// WRONG: Boolean logic inverted - accepts invalid versions!
int validate_packet_header(uint8_t *pkt, size_t len) {
    if (len < 8) return -1;
    uint16_t magic = *(uint16_t*)pkt;
    if (magic != 0xABCD) return -1;
    uint8_t ver = pkt[2];
    if (ver < 2 && ver > 5) return -1;  // BUG: && should be ||
    return 0;  // accepts ver=1, ver=10, etc.
}

// WRONG: Algorithm destroyed by goto spaghetti, polynomial wrong
uint32_t compute_crc32(uint8_t *data, size_t len) {
    uint32_t crc = 0xFFFFFFFF;
    int state = 0;
loop_start:
    if (state >= len) goto done;
    crc ^= data[state];
    state++;
    crc = (crc >> 1) ^ 0x12345678;  // BUG: wrong polynomial, missing inner loop
    goto loop_start;
done:
    return ~crc;
}
```

---

### 1.2 Data flow and reachability

**Evaluates:** Whether variable updates (accumulation, state transitions, flag operations) and execution paths (success, error, edge cases) enable an analyst to trace how data evolves and understand what outcomes are possible.

**Evaluation Choices:**
    - **2 (Excellent):** Variable updates match source semantics precisely. All critical paths present. State transitions clear. Analyst can immediately trace data dependencies and outcomes.
    - **1 (Good):** Semantically correct with minor presentation differences. Extra temporaries from register allocation that follow clear patterns. Paths may be slightly reordered but all outcomes preserved.
    - **0 (Acceptable):** Correct behavior but mechanically different. More temporaries, paths merged (specific errors→generic), or verbose updates. Analyst can trace logic with careful examination.
    - **-1 (Poor):** Some data flow issues. Minor operation errors (x++ missing in one path), some paths merged inappropriately, or state updates partially incorrect. Analyst must verify carefully.
    - **-2 (Unusable):** Data flow wrong. Wrong operations (= instead of +=), missing critical paths (error handling gone), or flags never set/cleared. Would mislead analyst about program state evolution.

**Examples:**

**Score 2 (Excellent):**
```c
// State machine crystal clear, all transitions explicit
enum conn_state { IDLE, CONNECTING, CONNECTED, ERROR };

enum conn_state handle_connect(struct connection *conn, uint8_t *request) {
    if (conn->state != IDLE) {
        return ERROR;
    }

    if (request[0] != 0x01) {
        return ERROR;
    }

    conn->state = CONNECTING;
    conn->retry_count = 0;
    conn->flags |= FLAG_ACTIVE;

    if (send_syn(conn) < 0) {
        conn->state = ERROR;
        return ERROR;
    }

    conn->state = CONNECTED;
    return CONNECTED;
}
```

**Score 1 (Good):**
```c
// Some extra temporaries from register allocation but logic traceable
int handle_connect(struct connection *conn, uint8_t *request) {
    int current = conn->state;
    if (current != 0) {  // IDLE
        return 3;  // ERROR
    }

    uint8_t req_type = request[0];
    if (req_type != 0x01) {
        return 3;
    }

    int next = 1;  // CONNECTING
    conn->state = next;
    int count = 0;
    conn->retry_count = count;
    int new_flags = conn->flags | 0x10;
    conn->flags = new_flags;

    int result = send_syn(conn);
    if (result < 0) {
        conn->state = 3;
        return 3;
    }

    conn->state = 2;  // CONNECTED
    return 2;
}
```

**Score 0 (Acceptable):**
```c
// Error paths merged but all outcomes present, verbose updates
int handle_connect(struct connection *conn, uint8_t *request) {
    int error_code = 0;
    int temp_state = conn->state;

    if (temp_state != 0) {
        error_code = 1;
    }

    if (error_code == 0) {
        uint8_t req_byte = request[0];
        if (req_byte != 0x01) {
            error_code = 1;
        }
    }

    if (error_code == 0) {
        int s1 = 1;
        conn->state = s1;
        int c1 = 0;
        conn->retry_count = c1;
        int f1 = conn->flags;
        int f2 = f1 | 0x10;
        conn->flags = f2;

        int r1 = send_syn(conn);
        if (r1 < 0) {
            conn->state = 3;
            error_code = 1;
        } else {
            conn->state = 2;
        }
    }

    return (error_code == 0) ? 2 : 3;
}
```

**Score -1 (Poor):**
```c
// Missing flag update, retry_count wrong value
int handle_connect(struct connection *conn, uint8_t *request) {
    if (conn->state != 0) {
        return 3;
    }

    if (request[0] != 0x01) {
        return 3;
    }

    conn->state = 1;
    conn->retry_count = 1;  // BUG: should be 0
    // BUG: Missing conn->flags |= 0x10

    if (send_syn(conn) < 0) {
        return 3;  // BUG: state not updated to ERROR
    }

    conn->state = 2;
    return 2;
}
```

**Score -2 (Unusable):**
```c
// Multiple critical state updates missing/wrong, path missing
int handle_connect(struct connection *conn, uint8_t *request) {
    if (request[0] != 0x01) {  // BUG: missing state check
        return 3;
    }

    conn->state = 2;  // BUG: skips CONNECTING state entirely
    conn->retry_count++;  // BUG: should reset to 0
    // BUG: Missing flags update
    // BUG: Missing send_syn error handling

    return 2;
}
```

---

## **2. Data Model Clarity**

### 2.1 Type correctness

**Evaluates:** Whether types accurately represent data semantics (pointer vs value, buffer sizes, signedness affecting comparisons) to help an analyst understand memory operations and identify potential vulnerabilities.

**Evaluation Choices:**
    - **2 (Excellent):** Types match semantics precisely. Pointer levels correct, signedness correct where it matters, buffer sizes accurate. Enables immediate understanding of memory operations and potential vulnerabilities.
    - **1 (Good):** Minor type imprecision that doesn't affect analysis. Generic widths (int for uint32_t) but signedness correct. An analyst understands memory model without confusion.
    - **0 (Acceptable):** Generic types (unsigned, int) that preserve behavior on target platform. Lacks precision but doesn't obscure operations. Analyst can infer semantics from usage context.
    - **-1 (Poor):** Some type issues. Wrong width for critical buffers, or minor signedness issues that could affect edge cases. Analyst must be careful about memory operations.
    - **-2 (Unusable):** Types actively mislead. Wrong pointer levels (T* vs T**), signed types for sizes (enables negative bypasses), wrong buffer dimensions. Would cause analyst to miss vulnerabilities or misunderstand memory model.

**Examples:**

**Score 2 (Excellent):**
```c
// Types precisely capture memory semantics
int copy_packet_data(uint8_t *dest, size_t dest_size,
                     const uint8_t *packet, uint16_t packet_len) {
    if (packet_len > dest_size) {
        return -1;  // overflow check clear
    }
    memcpy(dest, packet, packet_len);
    return 0;
}

// Pointer indirection and size tracking crystal clear
char* parse_length_string(uint8_t **cursor, size_t *remaining) {
    uint8_t len = **cursor;
    (*cursor)++;
    (*remaining)--;

    if (len > *remaining) return NULL;

    char *str = malloc(len + 1);
    memcpy(str, *cursor, len);
    str[len] = '\0';

    *cursor += len;
    *remaining -= len;
    return str;
}
```

**Score 1 (Good):**
```c
// Generic unsigned but semantics clear, width difference doesn't matter here
int copy_packet_data(unsigned char *dest, unsigned int dest_size,
                     const unsigned char *packet, unsigned int packet_len) {
    if (packet_len > dest_size) {
        return -1;
    }
    memcpy(dest, packet, packet_len);
    return 0;
}

// Pointer flattened but logic preserves semantics
char* parse_length_string(unsigned char *buf, unsigned int len) {
    unsigned char str_len = buf[0];
    buf++;
    len--;

    if (str_len > len) return NULL;

    char *str = malloc(str_len + 1);
    memcpy(str, buf, str_len);
    str[str_len] = '\0';
    return str;
}
```

**Score 0 (Acceptable):**
```c
// Very generic types but usage context makes operations clear
int copy_packet_data(void *dest, int dest_size,
                     void *packet, int packet_len) {
    if (packet_len > dest_size) {
        return -1;
    }
    memcpy(dest, packet, packet_len);
    return 0;
}

// Pointer arithmetic less clear but traceable
char* parse_length_string(char *buf, int len) {
    int str_len = (unsigned char)buf[0];
    buf = buf + 1;
    len = len - 1;

    if (str_len > len) return NULL;

    char *str = malloc(str_len + 1);
    memcpy(str, buf, str_len);
    str[str_len] = 0;
    return str;
}
```

**Score -1 (Poor):**
```c
// Wrong width for dest_size could matter in edge cases
int copy_packet_data(uint8_t *dest, uint16_t dest_size,  // BUG: should be size_t
                     const uint8_t *packet, uint16_t packet_len) {
    if (packet_len > dest_size) {
        return -1;
    }
    memcpy(dest, packet, packet_len);
    return 0;
}

// Pointer level confusion with len_ptr
char* parse_length_string(unsigned char *buf, unsigned int len) {
    unsigned char *len_ptr = buf;  // treating value as pointer
    buf++;
    len--;

    if (*len_ptr > len) return NULL;

    char *str = malloc(*len_ptr + 1);
    memcpy(str, buf, *len_ptr);
    str[*len_ptr] = '\0';
    return str;
}
```

**Score -2 (Unusable):**
```c
// CRITICAL: Signed types enable negative bypass of security check!
int copy_packet_data(char *dest, int dest_size,
                     const char *packet, int packet_len) {
    if (packet_len > dest_size) {  // BUG: negative packet_len bypasses!
        return -1;
    }
    memcpy(dest, packet, packet_len);
    return 0;
}

// CRITICAL: Wrong pointer level completely changes semantics
char* parse_length_string(unsigned char **buf_ptr, unsigned int len) {
    unsigned char len_val = *buf_ptr;  // BUG: dereferencing pointer not value
    (*buf_ptr)++;

    if (len_val > len) return NULL;

    char *str = malloc(len_val + 1);
    memcpy(str, *buf_ptr, len_val);
    str[len_val] = '\0';
    return str;
}
```

---

### 2.2 Structure layout

**Evaluates:** Whether struct/union definitions have correct fields, types, and memory layout to help an analyst understand data organization and recognize patterns (protocol headers, linked structures).

**Evaluation Choices:**
    - **2 (Excellent):** Structure layout matches source semantics. Fields present with descriptive or acceptably generic names, correct types, proper alignment. Analyst immediately recognizes pattern (protocol header, linked list, etc.).
    - **1 (Good):** Structure correct with minor differences. Some generic field names (field_0) or slightly different types that don't affect layout. Analyst understands organization quickly.
    - **0 (Acceptable):** Correct memory layout but abstraction loss. Fields packed into arrays, very generic names, or some fields not distinguished. Analyst can reconstruct purpose from usage.
    - **-1 (Poor):** Some layout issues. Wrong types affecting sizes, some fields missing or extra, or critical field misaligned. Analyst must carefully verify layout.
    - **-2 (Unusable):** Layout wrong. Fields merged incorrectly, wrong offsets, wrong sizes, or structure misrepresented. Would mislead analyst about memory organization.

**Examples:**

**Score 2 (Excellent):**
```c
struct packet_header {
    uint8_t  msg_type;
    uint8_t  flags;
    uint16_t payload_len;
    uint8_t  payload[256];
};

struct connection_node {
    int conn_id;
    uint32_t remote_addr;
    uint16_t remote_port;
    struct connection_node *next;
};
```

**Score 1 (Good):**
```c
struct packet {
    unsigned char type;
    unsigned char flags;
    unsigned short length;  // name variation
    unsigned char data[256];
};

struct node {
    int id;
    unsigned int addr;
    unsigned short port;
    struct node *next_node;  // name variation
};
```

**Score 0 (Acceptable):**
```c
struct packet {
    unsigned char header[2];  // type and flags packed
    unsigned short len;
    unsigned char buf[256];
};

struct node {
    int field0;
    unsigned int field1;
    unsigned short field2;
    struct node *field3;
};
```

**Score -1 (Poor):**
```c
struct packet {
    unsigned short header;  // BUG: wrong - merges 2 bytes into 1 field
    unsigned short len;
    unsigned char buf[256];
};

struct node {
    int id;
    unsigned int addr;
    // BUG: Missing port field
    struct node *next;
};
```

**Score -2 (Unusable):**
```c
struct packet {
    uint16_t header;        // BUG: merges type+flags into wrong type
    uint32_t len;           // BUG: 32-bit instead of 16-bit
    uint8_t  buf[128];      // BUG: wrong size
};

struct node {
    uint64_t data;          // BUG: completely wrong fields
    struct node next;       // BUG: embedded not pointer!
};
```

---

### 2.3 Pointers and collections

**Evaluates:** Whether pointer indirection (T* vs T**, value vs reference) and collection semantics (fixed/dynamic arrays, buffer+size pairs, bounds) enable an analyst to reason about memory safety, aliasing, and buffer boundaries.

**Evaluation Choices:**
    - **2 (Excellent):** Pointer indirection correct, collection semantics clear. Fixed vs dynamic arrays distinguished, bounds tracked. Analyst can immediately reason about memory safety and ownership.
    - **1 (Good):** Minor variations in API (return value vs out-param) but pointer semantics preserved. Analyst understands memory model without confusion.
    - **0 (Acceptable):** Semantically equivalent but presentation differs. Some pointer levels flattened, generic buffer sizes, but bounds logic preserved. Analyst can trace memory operations with effort.
    - **-1 (Poor):** Some indirection issues. Confusion between array and pointer in places, or bounds checking partially wrong. Analyst must carefully verify memory operations.
    - **-2 (Unusable):** Indirection wrong. Wrong pointer levels (T* as T**), embedded vs heap confused, or bounds missing/wrong. Would cause analyst to miss buffer overflows or misunderstand memory model.

**Examples:**

**Score 2 (Excellent):**
```c
struct list_node {
    int value;
    struct list_node *next;
};

struct list_node* list_prepend(struct list_node *head, int value) {
    struct list_node *node = malloc(sizeof(struct list_node));
    if (!node) return head;
    node->value = value;
    node->next = head;
    return node;
}

#define BUFFER_SIZE 256
struct buffer {
    uint8_t data[BUFFER_SIZE];  // fixed array
    size_t  length;
};
```

**Score 1 (Good):**
```c
struct node {
    int val;
    struct node *next;
};

// API variation: out-param instead of return value
void list_prepend(struct node **head, int value) {
    struct node *n = malloc(sizeof(struct node));
    if (!n) return;
    n->val = value;
    n->next = *head;
    *head = n;
}

struct buffer {
    unsigned char data[256];  // hardcoded size
    unsigned int length;
};
```

**Score 0 (Acceptable):**
```c
struct node {
    int value;
    struct node *next;
};

// Pointer level flattened but logic works
struct node* list_prepend(struct node *head, int value) {
    struct node temp;
    struct node *n = &temp;
    n = malloc(sizeof(struct node));  // awkward but correct
    if (n == NULL) return head;
    n->value = value;
    n->next = head;
    return n;
}

struct buffer {
    void *data;  // less clear but size tracked separately
    int capacity;  // = 256
    int length;
};
```

**Score -1 (Poor):**
```c
struct node {
    int value;
    struct node *next;
};

struct node* list_prepend(struct node *head, int value) {
    struct node *n = malloc(sizeof(int) + sizeof(void*));  // BUG: wrong size calc
    if (!n) return head;
    n->value = value;
    n->next = head;
    return n;
}

struct buffer {
    unsigned char data[256];
    // BUG: Missing length field - unbounded!
};
```

**Score -2 (Unusable):**
```c
struct node {
    int value;
    struct node next;  // BUG: embedded not pointer!
};

// Completely wrong - infinite recursion structure
struct node* list_prepend(struct node *head, int value) {
    struct node n;
    n.value = value;
    n.next = *head;  // BUG: trying to copy infinite structure
    return &n;       // BUG: returning stack address
}

struct buffer {
    unsigned char *data;  // BUG: pointer not fixed array
    int length;           // BUG: no capacity tracking
};
```

---

## **3. Naming Quality**

### 3.1 Artifact elimination and consistency

**Evaluates:** Whether decompiler artifacts (`v11`, `sub_401000`, `a1`, `FUN_00401000`) are removed and naming conventions are consistent.

**This is HIGH PRIORITY.** Binary/tool artifacts significantly impede analysis.

**Evaluation Choices:**
    - **2 (Excellent):** Zero artifacts. Descriptive or acceptably generic names (buf, len, data, i, j). Consistent conventions. Professional presentation.
    - **1 (Good):** Zero artifacts. Very minimal naming (func1, var1) or minor convention inconsistencies. Generic but consistent. Doesn't impede analysis.
    - **0 (Acceptable):** Mostly artifact-free but some remain in less critical areas (local temps like v1 but functions named). Or extremely minimal automated naming. Analyst can work but with minor friction.
    - **-1 (Poor):** Artifacts present in significant areas. Function names like sub_XXXXX, or parameters like a1-a9. Forces analyst to mentally translate constantly.
    - **-2 (Unusable):** Heavy artifacts throughout. v11, sub_401000, a1-a9, param_1, local_38, FUN_XXXXX, DAT_XXXXX everywhere. Immediate red flag, requires extensive cleanup before analysis.

**Examples:**

**Score 2 (Excellent):**
```c
// Clean, professional names - analyst works immediately
int validate_auth_token(const char *token, size_t token_len) {
    if (token_len < 16) return 0;

    uint8_t hash[32];
    compute_sha256(hash, (uint8_t*)token, token_len);

    for (int i = 0; i < 32; i++) {
        if (hash[i] != expected_hash[i]) {
            return 0;
        }
    }
    return 1;
}

// Or acceptably generic but consistent
int check_token(const char *buf, size_t len) {
    if (len < 16) return 0;

    uint8_t digest[32];
    compute_sha256(digest, (uint8_t*)buf, len);

    for (int i = 0; i < 32; i++) {
        if (digest[i] != expected[i]) {
            return 0;
        }
    }
    return 1;
}
```

**Score 1 (Good):**
```c
// Very minimal but no artifacts, consistent
int func3(const char *arg1, size_t arg2) {
    if (arg2 < 16) return 0;

    uint8_t arr1[32];
    compute_sha256(arr1, (uint8_t*)arg1, arg2);

    for (int i = 0; i < 32; i++) {
        if (arr1[i] != arr2[i]) {
            return 0;
        }
    }
    return 1;
}
```

**Score 0 (Acceptable):**
```c
// Function named but locals still have artifacts
int validate_token(const char *token, size_t len) {
    if (len < 16) return 0;

    uint8_t v1[32];  // artifact in local
    compute_sha256(v1, (uint8_t*)token, len);

    int v2 = 0;
    while (v2 < 32) {
        if (v1[v2] != expected[v2]) {
            return 0;
        }
        v2++;
    }
    return 1;
}
```

**Score -1 (Poor):**
```c
// Function has artifact, params generic but tolerable
int sub_401234(const char *arg1, size_t arg2) {
    if (arg2 < 0x10) return 0;

    uint8_t buf[32];
    compute_sha256(buf, (uint8_t*)arg1, arg2);

    for (int i = 0; i < 32; i++) {
        if (buf[i] != expected[i]) {
            return 0;
        }
    }
    return 1;
}
```

**Score -2 (Unusable):**
```c
// Artifact soup - immediate blocker
int FUN_00401234(const char *param_1, size_t param_2) {
    if (param_2 < 0x10) return 0;

    uint8_t local_38[32];
    compute_sha256(local_38, (uint8_t*)param_1, param_2);

    int iVar1 = 0;
    while (iVar1 < 0x20) {
        if (local_38[iVar1] != DAT_00404000[iVar1]) {
            return 0;
        }
        iVar1 = iVar1 + 1;
    }
    return 1;
}
```

---

### 3.2 Semantic naming

**Evaluates:** Whether names convey purpose and intent (function operations, variable roles, data types) or are at least neutral and non-misleading.

**Evaluation Choices:**
    - **2 (Excellent):** Names descriptive and domain-appropriate. Functions describe operations (validate_signature, parse_header). Variables describe roles (user_id, retry_count). Analyst understands purpose from names alone.
    - **1 (Good):** Names somewhat helpful. Mix of descriptive and generic but consistent patterns. Analyst gets useful hints from names.
    - **0 (Acceptable):** Neutral generic names (process, handle, check, buf, data, count). Don't add insight but don't mislead. Analyst relies on implementation.
    - **-1 (Poor):** Some misleading names. Function named "check" actually modifies state, or variable name suggests wrong purpose. Creates minor confusion.
    - **-2 (Unusable):** Actively misleading names. "encrypt" does XOR, "checksum" is version number, "user_id" holds IP. Creates false mental models that analyst must unlearn.

**Examples:**

**Score 2 (Excellent):**
```c
// Names immediately convey purpose
void apply_xor_obfuscation(uint8_t *data, size_t len, uint8_t key) {
    for (size_t i = 0; i < len; i++) {
        data[i] ^= key;
    }
}

struct user_session {
    uint32_t user_id;
    uint64_t expiration_time;
    uint8_t  auth_signature[32];
};
```

**Score 1 (Good):**
```c
// Names provide some context
void apply_mask(uint8_t *data, size_t len, uint8_t key) {
    for (size_t i = 0; i < len; i++) {
        data[i] ^= key;
    }
}

struct session {
    uint32_t uid;
    uint64_t expire_ts;
    uint8_t  sig[32];
};
```

**Score 0 (Acceptable):**
```c
// Generic but not misleading
void transform(uint8_t *buf, size_t len, uint8_t param) {
    for (size_t i = 0; i < len; i++) {
        buf[i] ^= param;
    }
}

struct session {
    uint32_t id;
    uint64_t timestamp;
    uint8_t  data[32];
};
```

**Score -1 (Poor):**
```c
// Mildly misleading - "encrypt" suggests more than XOR
void encrypt(uint8_t *buf, size_t len, uint8_t param) {
    for (size_t i = 0; i < len; i++) {
        buf[i] ^= param;
    }
}

struct session {
    uint32_t token;        // actually user_id
    uint64_t created;      // actually expiration
    uint8_t  hash[32];     // actually signature
};
```

**Score -2 (Unusable):**
```c
// Completely misleading - claims AES!
void aes_encrypt_256(uint8_t *plaintext, size_t len, uint8_t key) {
    for (size_t i = 0; i < len; i++) {
        plaintext[i] ^= key;  // NOT AES!
    }
}

struct session {
    uint32_t ip_address;   // WRONG: actually user_id
    uint64_t file_size;    // WRONG: actually timestamp
    uint8_t  checksum[32]; // WRONG: actually signature
};
```

---

## **4. Readability**

### 4.1 Visual formatting

**Evaluates:** Whether formatting (indentation, spacing, brace style) is clean and consistent enough to visually parse block structure without effort.

**Evaluation Choices:**
    - **2 (Excellent):** Clean, consistent formatting. Proper indentation, logical blank lines, idiomatic brace style. Easy to scan and navigate.
    - **1 (Good):** Generally clean with minor quirks. Slightly inconsistent spacing or brace placement but structure clear.
    - **0 (Acceptable):** Some formatting issues but readable. Cramped in places or inconsistent, but analyst can parse structure.
    - **-1 (Poor):** Formatting makes code harder to read. Significant inconsistencies, poor indentation. Analyst must mentally reformat.
    - **-2 (Unusable):** Formatting severely impedes reading. Code jammed on few lines, random indentation, or no structure visible. Must reformat before analysis.

**Examples:**

**Score 2 (Excellent):**
```c
int process_buffer(const uint8_t *buf, size_t len, uint8_t target) {
    size_t i;
    int matches = 0;

    for (i = 0; i < len; i++) {
        if (buf[i] == target) {
            matches++;
        }
    }

    return matches;
}
```

**Score 1 (Good):**
```c
int process_buffer(const uint8_t *buf, size_t len, uint8_t target)
{
  size_t i;
  int matches = 0;
  for (i = 0; i < len; i++) {
    if (buf[i] == target) {
      matches++;
    }
  }
  return matches;
}
```

**Score 0 (Acceptable):**
```c
int process_buffer(const uint8_t *buf, size_t len, uint8_t target)
{
  size_t i; int matches = 0;  // cramped
  for (i = 0; i < len; i++)
  {
      if (buf[i] == target)
      {
        matches++;
      }
  }
 return matches;  // misaligned
}
```

**Score -1 (Poor):**
```c
int process_buffer(const uint8_t *buf,size_t len,
uint8_t target){
size_t i;int matches=0;
for(i=0;i<len;i++){
if(buf[i]==target){
matches++;}
}
return matches;}
```

**Score -2 (Unusable):**
```c
int process_buffer(const uint8_t *buf,size_t len,uint8_t target){size_t i;int matches=0;for(i=0;i<len;i++){if(buf[i]==target){matches++;}}return matches;}
```

---

### 4.2 Logical organization and documentation

**Evaluates:** Whether functional phases (validation → parsing → processing) are separated and whether comments add insight or cause confusion.

**Evaluation Choices:**
    - **2 (Excellent):** Clear phase separation (blank lines, helpers, comments marking sections). Comments explain non-obvious algorithms, security properties, or intent. Aids rapid triage.
    - **1 (Good):** Phases distinguishable. Some organization visible. Comments present and helpful or neutral.
    - **0 (Acceptable):** Linear flow without explicit structure but sequence logical. No comments or neutral comments. Analyst follows flow linearly.
    - **-1 (Poor):** Some organizational issues. Phases somewhat mixed, or comments partially misleading. Analyst must carefully track flow.
    - **-2 (Unusable):** Logic tangled - validation mixed with processing, error handling scattered. OR comments actively mislead about algorithms or security. Analyst must untangle.

**Examples:**

**Score 2 (Excellent):**
```c
int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
    // Validate packet size
    if (len < HEADER_SIZE) return -1;

    // Parse header
    if (parse_header(&c->hdr, buf) < 0) return -1;

    // Parse payload
    const uint8_t *payload = buf + HEADER_SIZE;
    if (parse_payload(&c->payload, payload, len - HEADER_SIZE) < 0) return -1;

    // Verify integrity
    if (!verify_checksum(&c->hdr, &c->payload)) return -1;

    return 0;
}

// XOR obfuscation - symmetric operation
void xor_transform(uint8_t *buf, size_t len, uint8_t key) {
    for (size_t i = 0; i < len; i++) {
        buf[i] ^= key;
    }
}
```

**Score 1 (Good):**
```c
int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
    if (len < HEADER_SIZE) return -1;

    // Parse
    if (parse_header(&c->hdr, buf) < 0) return -1;
    const uint8_t *payload = buf + HEADER_SIZE;
    if (parse_payload(&c->payload, payload, len - HEADER_SIZE) < 0) return -1;

    // Check integrity
    if (!verify_checksum(&c->hdr, &c->payload)) return -1;

    return 0;
}

void xor_transform(uint8_t *buf, size_t len, uint8_t key) {
    // Apply XOR
    for (size_t i = 0; i < len; i++) {
        buf[i] ^= key;
    }
}
```

**Score 0 (Acceptable):**
```c
// No comments, linear flow but sequence clear
int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
    if (len < HEADER_SIZE) return -1;
    if (parse_header(&c->hdr, buf) < 0) return -1;
    const uint8_t *payload = buf + HEADER_SIZE;
    if (parse_payload(&c->payload, payload, len - HEADER_SIZE) < 0) return -1;
    if (!verify_checksum(&c->hdr, &c->payload)) return -1;
    return 0;
}

void xor_transform(uint8_t *buf, size_t len, uint8_t key) {
    for (size_t i = 0; i < len; i++) {
        buf[i] ^= key;
    }
}
```

**Score -1 (Poor):**
```c
// Phases somewhat jumbled, comments mildly wrong
int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
    if (len < HEADER_SIZE) return -1;

    // Verify packet
    if (parse_header(&c->hdr, buf) < 0) return -1;  // comment wrong phase

    if (!verify_checksum(&c->hdr, &c->payload)) {  // checksum before payload!
        return -1;
    }

    const uint8_t *payload = buf + HEADER_SIZE;
    if (parse_payload(&c->payload, payload, len - HEADER_SIZE) < 0) return -1;

    return 0;
}

void xor_transform(uint8_t *buf, size_t len, uint8_t key) {
    // TODO: implement proper encryption
    for (size_t i = 0; i < len; i++) {
        buf[i] ^= key;
    }
}
```

**Score -2 (Unusable):**
```c
// Logic scrambled, comments completely wrong
int handle_packet(struct ctx *c, const uint8_t *buf, size_t len) {
    int rc = 0;
    if (len >= HEADER_SIZE) {
        if (parse_header(&c->hdr, buf) < 0) {
            rc = -1;
        } else {
            if (!verify_checksum(&c->hdr, &c->payload)) {  // before payload parsed!
                rc = -1;
            } else {
                const uint8_t *payload = buf + HEADER_SIZE;
                if (parse_payload(&c->payload, payload, len - HEADER_SIZE) < 0) {
                    rc = -1;
                }
            }
        }
    } else {
        rc = -1;
    }
    return rc;
}

// CRITICAL: AES-256 encryption - DO NOT MODIFY
// This implements military-grade encryption
void xor_transform(uint8_t *buf, size_t len, uint8_t key) {
    // RSA key exchange protocol
    for (size_t i = 0; i < len; i++) {
        buf[i] ^= key;  // Quantum-resistant cipher
    }
}
```

---

### 4.3 Noise reduction

**Evaluates:** Whether the code is free of clutter (unused variables, dead code, goto spaghetti) that would obscure the actual algorithm.

**Evaluation Choices:**
    - **2 (Excellent):** Clean, focused code. No unused variables, dead code, or unnecessary constructs. Extra temporaries from register allocation OK if patterns clear. Algorithm immediately visible.
    - **1 (Good):** Mostly clean with minor artifacts. A few extra variables or slightly verbose patterns but core logic clear.
    - **0 (Acceptable):** Some clutter present (extra temporaries, redundant assignments, unnecessary labels) but follows patterns. Analyst can identify core operations with modest filtering.
    - **-1 (Poor):** Noticeable clutter. Multiple unused variables, some dead code, or convoluted patterns. Analyst must carefully separate signal from noise.
    - **-2 (Unusable):** Heavy clutter. Unused variables everywhere, unreachable dead code, goto spaghetti, debug statements. Algorithm obscured. Requires cleanup before analysis.

**Examples:**

**Score 2 (Excellent):**
```c
uint32_t simple_checksum(const uint8_t *buf, size_t len) {
    uint32_t sum = 0;
    for (size_t i = 0; i < len; i++) {
        sum += buf[i];
    }
    return sum;
}
```

**Score 1 (Good):**
```c
uint32_t simple_checksum(const uint8_t *buf, size_t len) {
    uint32_t sum = 0;
    size_t i = 0;
    uint8_t byte_val;  // extra temp but pattern clear

    for (i = 0; i < len; i++) {
        byte_val = buf[i];
        sum += byte_val;
    }
    return sum;
}
```

**Score 0 (Acceptable):**
```c
uint32_t simple_checksum(const uint8_t *buf, size_t len) {
    uint32_t sum = 0;
    size_t i = 0;
    uint8_t b;

    while (i < len) {
        b = buf[i];
        sum = sum + b;
        i = i + 1;
    }

    return sum;
}
```

**Score -1 (Poor):**
```c
uint32_t simple_checksum(const uint8_t *buf, size_t len) {
    uint32_t sum = 0;
    uint32_t temp1 = 0;
    uint32_t temp2 = 0;
    int flag = 0;  // unused
    size_t i = 0;

    while (i < len) {
        temp1 = buf[i];
        temp2 = temp1;
        sum = sum + temp2;
        i = i + 1;
    }

    return sum;
}
```

**Score -2 (Unusable):**
```c
uint32_t simple_checksum(const uint8_t *buf, size_t len) {
    uint32_t sum = 0;
    uint32_t tmp1 = 0;
    uint32_t tmp2 = 0;
    uint32_t debug_val = 0;
    uint32_t unused = 0;
    int flag = 0;
    size_t i = 0;

    // Dead code
    if (0) {
        for (int j = 0; j < 1000; j++) {
            debug_val += j;
        }
    }

loop_start:
    if (i >= len) goto done;
    tmp1 = buf[i];
    tmp2 = tmp1;
    sum = sum + tmp2;
    unused = sum ^ 0;
    flag = 1;
    i = i + 1;
    goto loop_start;

done:
    return sum;
}
```

---

## **Evaluation Output Format**

After completing your evaluation, you MUST save your scores to `/workspace/evaluation.json` in the following JSON format:

```json
{
  "behavioral_correctness": {
    "control_flow_and_conditions": {
      "score": 2,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "data_flow_and_reachability": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "data_model_clarity": {
    "type_correctness": {
      "score": 2,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "structure_layout": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "pointers_and_collections": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "naming_quality": {
    "consistency_and_artifacts": {
      "score": -1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "semantic_naming": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "readability": {
    "visual_formatting": {
      "score": 2,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "logical_organization_and_documentation": {
      "score": 1,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    },
    "noise_reduction": {
      "score": 0,
      "reasoning": "Brief explanation referencing specific examples from the pseudocode"
    }
  },
  "summary": {
    "total_score": 8,
    "max_possible": 20,
    "overall_assessment": "Brief 2-3 sentence summary of the pseudocode quality, highlighting strengths and weaknesses"
  }
}
```

**Note:** Scores range from -2 to 2 for each criterion. Total score is the sum of all 10 criteria (range: -20 to +20).
